{"version":3,"sources":["Contexts/AlgorithmContext.tsx","Contexts/KeyContext.tsx","Components/App/Container/Canvas/GraphNode/GraphNode.tsx","Components/App/Container/Canvas/GraphNode/index.ts","helper.ts","Components/App/Container/Canvas/GraphEdge/GraphEdge.tsx","Components/App/Container/Canvas/GraphEdge/index.ts","Components/App/Container/Canvas/GhostEdge/GhostEdge.tsx","Components/App/Container/Canvas/GhostEdge/index.ts","Hooks/useTransformation.ts","Classes/PQNode.ts","Classes/PriorityQueue.ts","algorithms.ts","Hooks/useAlgorithms.ts","Components/App/Container/Canvas/Canvas.tsx","Components/App/Container/Canvas/index.ts","Components/App/Container/Navbar/Title/Title.tsx","Components/App/Container/Navbar/Title/index.ts","Components/App/Container/Navbar/NavTab/NavTab.tsx","Components/App/Container/Navbar/NavTab/index.ts","Components/App/Container/Navbar/PopOver/PopOver.tsx","Components/App/Container/Navbar/PopOver/index.ts","Components/App/Container/Navbar/Navbar.tsx","Components/App/Container/Navbar/index.ts","Components/App/Container/AlgorithmBar/AlgorithmBar.tsx","Components/App/Container/AlgorithmBar/index.ts","Components/App/Container/Modal/Modal.tsx","Components/App/Container/Modal/index.ts","Components/App/Container/Container.tsx","Components/App/Container/index.ts","Components/App/index.ts","Components/App/App.tsx","index.tsx"],"names":["AlgoStateContext","createContext","undefined","AlgoDispatchContext","algoReducer","state","action","type","status","ready","value","newValue","name","category","newName","newStatus","Error","AlgoProvider","children","useReducer","dispatch","Provider","useAlgoState","context","React","useContext","useAlgoDispatch","AcceptedKeys","KeyStateContext","KeyDispatchContext","keyReducer","console","log","key","includes","isPressed","KeyProvider","grow","keyframes","pop","StyledNode","styled","Icon","FontAwesomeIcon","DotCircle","BullsEye","Seedling","Faucet","Sink","GraphNode","id","x","y","handleMouseDown","handleMouseUp","isSource","isTarget","algoState","style","left","top","onMouseDown","e","stopPropagation","preventDefault","onMouseUp","onContextMenu","icon","faDotCircle","faSeedling","faFaucet","faBullseye","faSink","getAngleRad","x1","y1","x2","y2","Math","atan2","getDistance","sqrt","pow","screenToWorld","offsetX","offsetY","iScreenX","iScreenY","scale","pathRegular","pathSpecial","arrowRegular","arrowSpecial","mstRegularAnimation","mstSpecialAnimation","traverse","StyledEdge","props","animation","interval","ArrowHead","show","ChevronRight","Flow","saturation","Label","div","GraphEdge","headNode","className","tailNode","handleClick","weight","showLabel","optionalValue","updateEdgeWeight","width","degree","EDGE_HEIGHT","animationRef","useRef","useState","setSaturation","useEffect","prev","round","current","labelRef","height","transform","onClick","faChevronRight","size","faArrowRight","contentEditable","onInput","input","currentTarget","innerHTML","test","parseInt","ref","StyledGhostEdge","GhostEdge","tailPosition","initialState","isStateValid","worldSpaceWidth","window","innerWidth","worldSpaceHeight","innerHeight","abs","transformReducer","newStateFromPan","currentState","panProps","movementX","movementY","newStateFromZoom","zoomProps","scaleProps","currentScale","newScale","delta","min","maxScale","max","minScale","pageX","pageY","worldXBeforeZoom","worldYBeforeZoom","deltaOffsetX","deltaOffsetY","zoom","PQNode","item","priority","right","parent","this","isRoot","PriorityQueue","root","lastAdded","keyToNode","Map","child","tempKey","tempPriority","set","node","currNode","swap","isLeaf","childNode","newNode","isLeftChild","sibling","get","upheap","insert","isEmpty","delete","isRightChild","downheap","has","getPathToNode","edges","path","curr","edge","find","unshift","findRoot","merge","u","v","rank","uParent","vParent","uRank","vRank","findAugmentingPath","vertices","source","sink","visited","queue","push","shift","outEdges","filter","capacity","i","length","neighbor","getConnectedComponents","cc","Set","ccNum","forEach","explore","E","add","fulkerson","V","residualEdges","isReverse","reverseHead","reverseTail","getResidualGraph","residualE","maxFlow","traversed","pathFlow","Infinity","s","residualForwardEdge","residualBackwardEdge","edgeFlow","realEdge","residualV","useAlgorithms","setSource","target","setTarget","setSourceNode","setTargetNode","runPathAlgorithm","algorithm","nodes","dist","PQ","enqueue","dequeue","outgoingEdges","uvDist","decreaseKey","shortestPath","dijkstra","stack","inEdge","dfs","bfs","heuristic","getHeuristic","aStar","runTreeAlgorithm","mst","incidentEdges","containsKey","uvWeight","prim","sortedEdges","sort","e1","e2","vertex","kruskal","runFlowAlgorithm","checkConnectedComponents","StyledDiv","scaleSensitivity","Canvas","clearGraphs","offClear","speed","setNodes","setEdges","ghostEdge","setGhostEdge","mouseIsHeld","mouseMoved","mouseDownNode","isMovingNode","dKeyPressed","keyState","useKeyState","setShowLabel","algoDispatch","transformState","pan","useCallback","useTransformation","timer","index","algoOutput","algoPath","maxFlowOutput","prevFlow","setEdgeAnimation","optional","map","resetAllEdgeAnimation","visualizePath","array","targetPath","setTimeout","clearTimeout","visualizeMST","visualizeMaxFlow","flow","stepAlgorithmForward","oldFlow","tempEdge","tempFlow","stepAlgorithmBackward","deleteNode","setMouseDownNode","nodeID","n","prevNodes","prevNode","deleteIncidentEdges","addEdge","head","tail","edgeLength","newEdge","uuidv4","outEdgeIDs","inEdgeIDs","prevEdges","deleteEdge","edgeID","incidentEdgeIDs","prevEdge","newWeight","handleMouseUpOnNode","currStatus","isReady","event","coor","screenX","screenY","addNode","clientX","clientY","onMouseMove","shiftKey","currX","currY","newGhostEdge","updateGhostEdge","onWheel","deltaY","onKeyDown","onKeyUp","tabIndex","transformOrigin","StyledTitle","h1","Title","StyledTab","NavTab","navTabRef","onMouseOver","StyledContainer","Content","xCoor","yCoor","ContentItem","Background","contentWidth","contentHeight","PopOver","contentRef","setContentRef","contentSize","setContentSize","onRefChange","offsetHeight","offsetWidth","tabRef","getBoundingClientRect","content","StyledNav","ClearButton","QuestionCircle","popOverContent","tree","initialPopOver","Navbar","popOver","setPopOver","algorithmState","showPopOver","hidePopOver","onMouseLeave","faQuestionCircle","color","onQuestionClick","onClear","Container","TitleContainer","ConfigContainer","StyledIcon","clickable","Slider","fadeIn","MessageContainer","RightContainer","CancelButton","AlgorithmBar","changeSpeed","message","setMessage","setColor","msg","faStepBackward","faRedo","faPause","faPlay","faStepForward","defaultValue","step","onChange","parseFloat","slideIn","Overlay","StyledModal","ModalTitle","h2","ModalSubTitle","h4","InstructionList","ul","InstructionItem","li","Bold","Modal","isOpen","toggle","clear","setClear","setSpeed","setIsOpen","keyDispatch","useKeyDispatch","handleToggle","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.de83f03c.chunk.js","sourcesContent":["import { stringify } from \"querystring\";\nimport React, { useReducer, createContext } from \"react\";\n\ntype Action =\n  | { type: \"start\" }\n  | { type: \"pause\" }\n  | { type: \"continue\" }\n  | { type: \"stepF\" }\n  | { type: \"stepB\" }\n  | { type: \"complete\"; newValue: string }\n  | { type: \"cancel\" }\n  | { type: \"set\"; newName: string; category: string | null; newStatus: string }\n  | { type: \"setStatus\"; newStatus: string; ready: boolean }\n  | { type: \"reset\" }\n  | { type: \"error\"; newStatus: string };\ntype Dispatch = (action: Action) => void;\ntype State = {\n  name: string | null;\n  category: string | null;\n  status: string | null;\n  ready: boolean;\n  value: string;\n};\ntype AlgoProviderProps = { children: React.ReactNode };\n\nconst AlgoStateContext = createContext<State | undefined>(undefined);\nconst AlgoDispatchContext = createContext<Dispatch | undefined>(undefined);\n\nfunction algoReducer(state: State, action: Action) {\n  switch (action.type) {\n    case \"start\":\n      return { ...state, status: \"running\", ready: true };\n    case \"pause\":\n      return { ...state, status: \"paused\" };\n    case \"continue\":\n      return { ...state, status: \"running\" };\n    case \"stepF\":\n      return { ...state, status: \"stepF\" };\n    case \"stepB\":\n      return { ...state, status: \"stepB\" };\n    case \"complete\":\n      return { ...state, status: \"completed\", value: action.newValue };\n    case \"cancel\":\n      return {\n        name: null,\n        category: null,\n        status: null,\n        ready: false,\n        value: \"\",\n      };\n    case \"set\":\n      return {\n        name: action.newName,\n        category: action.category,\n        status: action.newStatus,\n        ready: false,\n        value: \"\",\n      };\n    case \"setStatus\":\n      return { ...state, status: action.newStatus, ready: action.ready };\n    case \"reset\":\n      return { ...state, status: \"setSource\", ready: false, value: \"\" };\n    case \"error\":\n      return { ...state, status: action.newStatus, ready: false, value: \"\" };\n\n    default:\n      throw new Error(`Unhandled action type`);\n  }\n}\n\nfunction AlgoProvider({ children }: AlgoProviderProps) {\n  const [state, dispatch] = useReducer(algoReducer, {\n    name: null,\n    category: null,\n    status: null,\n    ready: false,\n    value: \"\",\n  });\n\n  return (\n    <AlgoStateContext.Provider value={state}>\n      <AlgoDispatchContext.Provider value={dispatch}>\n        {children}\n      </AlgoDispatchContext.Provider>\n    </AlgoStateContext.Provider>\n  );\n}\n\nfunction useAlgoState() {\n  const context = React.useContext(AlgoStateContext);\n  if (context === undefined) {\n    throw new Error(\"useAlgoState must be used within a AlgoProvider\");\n  }\n  return context;\n}\n\nfunction useAlgoDispatch() {\n  const context = React.useContext(AlgoDispatchContext);\n  if (context === undefined) {\n    throw new Error(\"useAlgoDispatch must be used within a AlgoProvider\");\n  }\n  return context;\n}\n\nexport { AlgoProvider, useAlgoState, useAlgoDispatch };\n","import React, { useReducer, createContext } from \"react\";\n\ntype State = { key: string | null; isPressed: boolean | null };\ntype Action = { type: \"press\"; key: string } | { type: \"unpress\"; key: string };\ntype Dispatch = (action: Action) => void;\ntype KeyProviderProps = { children: React.ReactNode };\nconst AcceptedKeys = [\"Shift\", \"d\", \"w\"];\n\nconst KeyStateContext = createContext<State | undefined>(undefined);\nconst KeyDispatchContext = createContext<Dispatch | undefined>(undefined);\n\nfunction keyReducer(state: State, action: Action) {\n  switch (action.type) {\n    case \"press\":\n      console.log(action.key);\n      if (!AcceptedKeys.includes(action.key)) return { ...state };\n      console.log(action.key);\n      return { key: action.key, isPressed: true };\n    case \"unpress\":\n      if (state.key !== action.key) return { ...state };\n      return { ...state, isPressed: false };\n    default:\n      throw new Error(`Unhandled action type`);\n  }\n}\n\nfunction KeyProvider({ children }: KeyProviderProps) {\n  const [state, dispatch] = useReducer(keyReducer, {\n    key: null,\n    isPressed: false,\n  });\n\n  return (\n    <KeyStateContext.Provider value={state}>\n      <KeyDispatchContext.Provider value={dispatch}>\n        {children}\n      </KeyDispatchContext.Provider>\n    </KeyStateContext.Provider>\n  );\n}\n\nfunction useKeyState() {\n  const context = React.useContext(KeyStateContext);\n  if (context === undefined) {\n    throw new Error(\"useKeyState must be used within a KeyStateProvider\");\n  }\n  return context;\n}\n\nfunction useKeyDispatch() {\n  const context = React.useContext(KeyDispatchContext);\n  if (context === undefined) {\n    throw new Error(\"useKeyDispatch must be used within a KeyStateProvider\");\n  }\n  return context;\n}\n\nexport { KeyProvider, useKeyState, useKeyDispatch };\n","import React, { useState, useEffect, useRef, CSSProperties } from \"react\";\nimport styled, { keyframes } from \"styled-components\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  faBullseye,\n  faDotCircle,\n  faSeedling,\n  faFaucet,\n  faSink,\n} from \"@fortawesome/free-solid-svg-icons\";\n\nimport { useAlgoState } from \"Contexts/AlgorithmContext\";\n\nexport interface GraphNodeProps extends React.HTMLAttributes<HTMLElement> {\n  id: string;\n  x: number;\n  y: number;\n  className?: string;\n  outEdgeIDs?: Array<string>;\n  inEdgeIDs?: Array<string>;\n  handleMouseDown?: (id: string) => void;\n  handleMouseUp?: (id: string) => void;\n  isSource?: boolean;\n  isTarget?: boolean;\n}\n\nconst grow = keyframes`\n  from {\n    transform: scale(0.5);\n  }\n  to {\n    transform: scale(1);\n  }\n`;\n\nconst pop = keyframes`\n  0% {\n    transform: scale(0);\n  }\n  75% {\n    transform: scale(1.2);\n  }\n  100% {\n    transform: scale(1);\n  }\n`;\n\nconst StyledNode = styled(\"div\")`\n  position: absolute;\n  z-index: 2;\n\n  height: 6px;\n  width: 6px;\n  border-radius: 50%;\n  background: #ffffff;\n  cursor: pointer;\n\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  animation: ${pop} 0.2s ease-out forwards;\n`;\n\nconst Icon = styled(FontAwesomeIcon)`\n  position: absolute;\n  height: 6px;\n  width: 6px;\n  animation: ${grow} 1s linear infinite;\n  animation-direction: alternate;\n`;\n\nconst DotCircle = styled(Icon)`\n  color: #21e6c1;\n`;\n\nconst BullsEye = styled(Icon)`\n  color: #ff4b5c;\n`;\n\nconst Seedling = styled(Icon)`\n  color: #b8de6f;\n`;\n\nconst Faucet = styled(Icon)`\n  color: #4c6ef5;\n`;\n\nconst Sink = styled(Icon)`\n  color: #4c6ef5;\n`;\n\nconst GraphNode: React.FC<GraphNodeProps> = ({\n  id,\n  x,\n  y,\n  handleMouseDown,\n  handleMouseUp,\n  isSource,\n  isTarget,\n}) => {\n  const algoState = useAlgoState();\n\n  return (\n    <StyledNode\n      style={{ left: x - 3, top: y - 3 }}\n      onMouseDown={(e) => {\n        e.stopPropagation();\n        e.preventDefault();\n        handleMouseDown!(id);\n      }}\n      onMouseUp={(e) => {\n        e.stopPropagation();\n        handleMouseUp!(id);\n      }}\n      onContextMenu={(e) => {\n        e.preventDefault();\n        return false;\n      }}\n    >\n      {isSource && algoState.category === \"path\" && (\n        <DotCircle icon={faDotCircle} />\n      )}\n      {isSource && algoState.category === \"tree\" && (\n        <Seedling icon={faSeedling} />\n      )}\n      {isSource && algoState.category === \"flow\" && <Faucet icon={faFaucet} />}\n      {isTarget && algoState.category === \"path\" && (\n        <BullsEye icon={faBullseye} />\n      )}\n      {isTarget && algoState.category === \"flow\" && <Sink icon={faSink} />}\n    </StyledNode>\n  );\n};\n\nexport default GraphNode;\n","import GraphNode from \"./GraphNode\";\nimport * as NodeModules from \"./GraphNode\";\n\nexport type GraphNodeProps = NodeModules.GraphNodeProps;\nexport default GraphNode;\n","import { TransformState } from \"Interfaces/TransformState\";\nimport { PanProps } from \"Interfaces/PanProps\";\nimport { ZoomProps } from \"Interfaces/ZoomProps\";\nimport { ScaleProps } from \"Interfaces/ScaleProps\";\n\nexport const getAngleRad = (x1: number, y1: number, x2: number, y2: number) => {\n  return Math.atan2(y2 - y1, x2 - x1);\n};\n\nexport const getDistance = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n): number => {\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n};\n\n// input: offsetX, offsetY : integers; fWorldX, fWorldY: floats\n// output: pair of screen coordinates; int[]\n// NOTE: in our usage, offsets should only be negative\nexport const worldToScreen = ({\n  offsetX,\n  offsetY,\n  fWorldX,\n  fWorldY,\n  scale,\n}: {\n  offsetX: number;\n  offsetY: number;\n  fWorldX: number;\n  fWorldY: number;\n  scale: number;\n}): number[] => {\n  let iScreenX = (fWorldX + offsetX) * scale;\n  let iScreenY = (fWorldY + offsetY) * scale;\n  return [iScreenX, iScreenY];\n};\n\n// input: all integers\n// output: pair of world coordinates; float[]\nexport const screenToWorld = ({\n  offsetX,\n  offsetY,\n  iScreenX,\n  iScreenY,\n  scale,\n}: {\n  offsetX: number;\n  offsetY: number;\n  iScreenX: number;\n  iScreenY: number;\n  scale: number;\n}): number[] => {\n  let fWorldX = iScreenX / scale - offsetX;\n  let fWorldY = iScreenY / scale - offsetY;\n  return [fWorldX, fWorldY];\n};\n\n// Return a new transformation state after pan event\nexport const pan = (\n  currentState: TransformState,\n  panProps: PanProps\n): TransformState => {\n  // subtraction translates mouse coordinate differences into world space offset;\n  // basically a screen to world transform so we need to divide by scale\n  return {\n    ...currentState,\n    offsetX: currentState.offsetX + panProps.movementX / currentState.scale,\n    offsetY: currentState.offsetY + panProps.movementY / currentState.scale,\n  };\n};\n\nexport const zoom = (\n  currentState: TransformState,\n  zoomProps: ZoomProps,\n  scaleProps: ScaleProps\n): TransformState => {\n  let currentScale = currentState.scale;\n  let newScale = zoomProps.delta > 0 ? currentScale * 1.1 : currentScale * 0.9;\n\n  // Restrict scale\n  newScale = Math.min(\n    scaleProps.maxScale,\n    Math.max(scaleProps.minScale, newScale)\n  );\n\n  // Get world space coordinate of zoom event before scale change\n  let [worldXBeforeZoom, worldYBeforeZoom] = screenToWorld({\n    offsetX: currentState.offsetX,\n    offsetY: currentState.offsetY,\n    iScreenX: zoomProps.pageX,\n    iScreenY: zoomProps.pageY,\n    scale: currentScale,\n  });\n\n  // Get world space coordinate of zoom event after scale change\n  let [worldXAfterZoom, worldYAfterZoom] = screenToWorld({\n    offsetX: currentState.offsetX,\n    offsetY: currentState.offsetY,\n    iScreenX: zoomProps.pageX,\n    iScreenY: zoomProps.pageY,\n    scale: newScale,\n  });\n\n  // Adjust offset according to difference in world space\n  let deltaOffsetX = worldXBeforeZoom - worldXAfterZoom;\n  let deltaOffsetY = worldYBeforeZoom - worldYAfterZoom;\n\n  return {\n    ...currentState,\n    offsetX: currentState.offsetX - deltaOffsetX,\n    offsetY: currentState.offsetY - deltaOffsetY,\n    scale: newScale,\n  };\n};\n","import React, { useEffect, useState, useRef } from \"react\";\nimport styled, {\n  css,\n  keyframes,\n  Keyframes,\n  FlattenSimpleInterpolation,\n} from \"styled-components\";\n\nimport { useAlgoState } from \"Contexts/AlgorithmContext\";\nimport { Node } from \"Components/App/Container/Canvas\";\nimport { getAngleRad, getDistance } from \"helper\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  faChevronRight,\n  faArrowRight,\n} from \"@fortawesome/free-solid-svg-icons\";\n\nexport interface GraphEdgeProps {\n  id: string;\n  headNode: Node;\n  tailNode: Node;\n  weight: number;\n  className?: string;\n  handleClick?: (id: string) => void;\n  showLabel: boolean;\n  animation: string | null;\n  optionalValue: number;\n  interval: number;\n  updateEdgeWeight: (edgeID: string, newWeight: number) => void;\n}\n\nconst EDGE_HEIGHT = 1.2;\n\n/********** KEYFRAMES **********/\n\nconst pathRegular = () => keyframes`\n  100% {\n    background: #19d3da;\n  }\n`;\n\nconst pathSpecial = () => keyframes`\n  100% {\n    background: #f1fa3c;\n  }\n`;\n\nconst arrowRegular = () => keyframes`\n  100% {\n    color: #19d3da;\n  }\n`;\n\nconst arrowSpecial = () => keyframes`\n  100% {\n    color: #f1fa3c;\n  }\n`;\n\nconst mstRegularAnimation = () => keyframes`\n  50% {\n    background: #ff414d;\n  }\n  100% {\n    background: none;\n  }\n`;\n\nconst mstSpecialAnimation = () => keyframes`\n  100% {\n    background: #b8de6f;\n  }\n`;\n\nconst flowAnimation = (saturation: number) => keyframes`\n  0% {\n    width: 0%;\n  }\n  100% {\n    width: 100%;\n    opacity: ${saturation};\n  }\n`;\n\nconst traverse = keyframes`\n  from {\n    left: calc(0% - 3px);\n  }\n  to {\n    left: calc(100% - 3px);\n  }\n`;\n\n/********** STYLED-COMPONENTS **********/\n\nconst StyledEdge = styled(\"div\")<{\n  animation: (() => Keyframes) | null;\n  interval: number;\n}>`\n  position: absolute;\n  background: #ffffff;\n  transform-origin: 0%;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  animation: ${(props) =>\n      props.animation === null ? \"none\" : props.animation()}\n    ${(props) => props.interval}s linear forwards;\n`;\n\nconst ArrowHead = styled(FontAwesomeIcon)<{\n  show: boolean;\n  animation: string | null;\n  interval: number;\n}>`\n  visibility: ${(props) => (props.show ? \"visible\" : \"hidden\")};\n  position: absolute;\n  right: 2.5px;\n  color: #ffffff;\n  height: 5px;\n  width: 5px !important;\n  animation: ${(props) =>\n      props.animation === null\n        ? \"none\"\n        : props.animation === \"regular\"\n        ? arrowRegular\n        : arrowSpecial}\n    ${(props) => props.interval}s linear forwards;\n`;\n\nconst ChevronRight = styled(FontAwesomeIcon)<{ interval: number }>`\n  position: absolute;\n  left: calc(0% - 3px);\n  height: 5px;\n  width: 5px !important;\n  color: #19d3da;\n  animation: ${traverse} ${(props) => props.interval}s linear;\n`;\n\nconst Flow = styled(\"div\")<{ saturation: number; interval: number }>`\n  position: absolute;\n  height: 100%;\n  width: 50%;\n  background-color: #4c6ef5;\n  opacity: 1;\n  animation: ${(props) => flowAnimation(props.saturation)}\n    ${(props) => props.interval}s linear forwards;\n`;\n\nconst Label = styled.div`\n  position: absolute;\n  display: block;\n  font-size: 4px;\n  background: transparent;\n  border: none;\n  color: white;\n  top: 1px;\n  display: inline-block;\n  text-align: center;\n  width: 100%;\n`;\n\nconst GraphEdge: React.FC<GraphEdgeProps> = ({\n  id,\n  className,\n  headNode,\n  tailNode,\n  handleClick,\n  weight,\n  showLabel,\n  animation,\n  optionalValue,\n  interval,\n  updateEdgeWeight,\n}) => {\n  const width = getDistance(headNode.x, headNode.y, tailNode.x, tailNode.y);\n  const degree = getAngleRad(headNode.x, headNode.y, tailNode.x, tailNode.y);\n  const left = headNode.x;\n  const top = headNode.y - EDGE_HEIGHT / 2; /* places center of edge on node */\n\n  const algoState = useAlgoState();\n  const animationRef = useRef<(() => Keyframes) | null>(null);\n\n  const [saturation, setSaturation] = useState<number>(0);\n\n  useEffect(() => {\n    if (algoState.category === \"flow\") {\n      setSaturation((prev) => Math.round((optionalValue / weight) * 100));\n    }\n  }, [weight, optionalValue]);\n\n  useEffect(() => {\n    if (animation === null) {\n      animationRef.current = null;\n      return;\n    }\n\n    switch (algoState.category) {\n      case \"path\":\n        animationRef.current =\n          animation === \"regular\" ? pathRegular : pathSpecial;\n        return;\n      case \"tree\":\n        animationRef.current =\n          animation === \"regular\" ? mstRegularAnimation : mstSpecialAnimation;\n        return;\n      case \"flow\":\n        animationRef.current = null;\n        return;\n      default:\n        animationRef.current = null;\n        return;\n    }\n  }, [animation]);\n\n  const labelRef = useRef<HTMLDivElement | null>(null);\n\n  return (\n    <StyledEdge\n      style={{\n        left: left,\n        top: top,\n        height: EDGE_HEIGHT,\n        width: width,\n        transform: `rotate(${degree}rad)`,\n      }}\n      onClick={(e) => {\n        e.stopPropagation();\n        handleClick!(id);\n      }}\n      animation={\n        animation === null\n          ? null\n          : algoState.category === \"path\" && animation === \"special\"\n          ? pathSpecial\n          : animationRef.current\n      }\n      interval={interval / 1000}\n    >\n      {animationRef.current && algoState.category === \"path\" && (\n        <ChevronRight\n          icon={faChevronRight}\n          size=\"1x\"\n          interval={interval / 1000}\n        />\n      )}\n      <ArrowHead\n        icon={faArrowRight}\n        size=\"1x\"\n        show={algoState.category !== \"tree\"}\n        animation={!animation ? null : animation}\n        interval={interval / 1000}\n      />\n      {animation === \"regular\" && algoState.category === \"flow\" && (\n        <Flow saturation={saturation} interval={interval / 1000} />\n      )}\n      {showLabel && (\n        <Label\n          contentEditable={!algoState.name}\n          onMouseDown={(e) => e.stopPropagation()}\n          onClick={(e) => e.stopPropagation()}\n          onMouseUp={(e) => e.stopPropagation()}\n          onInput={(e) => {\n            let input = e.currentTarget.innerHTML;\n            let isNum = /^\\d+$/.test(input);\n            if (isNum) updateEdgeWeight(id, parseInt(input, 10));\n            else labelRef.current!.innerHTML = `${weight}`;\n          }}\n          ref={labelRef}\n        >\n          {algoState.category === \"flow\"\n            ? `${optionalValue} / ${weight}`\n            : weight}\n        </Label>\n      )}\n    </StyledEdge>\n  );\n};\n\nexport default GraphEdge;\n","import GraphEdge from \"./GraphEdge\";\nimport * as EdgeModules from \"./GraphEdge\";\n\nexport type GraphEdgeProps = EdgeModules.GraphEdgeProps;\nexport default GraphEdge;\n","import React, { useState, useEffect, CSSProperties } from \"react\";\nimport styled from \"styled-components\";\n\nimport { getAngleRad, getDistance } from \"helper\";\nimport { GraphNodeProps } from \"Components/App/Container/Canvas/GraphNode\";\n\nexport interface Coordinate {\n  x: number;\n  y: number;\n}\n\nexport interface GhostEdgeProps {\n  className?: string;\n  headNode: GraphNodeProps;\n  tailPosition: Coordinate;\n}\n\nconst EDGE_HEIGHT = 1;\n\nconst StyledGhostEdge = styled(\"div\")<{\n  left: number;\n  top: number;\n  width: number;\n  degree: number;\n}>`\n  position: absolute;\n  left: ${(props) => props.left}px;\n  top: ${(props) => props.top}px;\n  height: ${EDGE_HEIGHT}px;\n  width: ${(props) => props.width}px;\n  height: ${EDGE_HEIGHT}px;\n  background: #ffffff;\n  opacity: 0.5;\n  transform-origin: 0%;\n  transform: rotate(${(props) => props.degree}rad);\n`;\n\nconst GhostEdge: React.FC<GhostEdgeProps> = ({\n  className,\n  headNode,\n  tailPosition,\n}) => {\n  const left = headNode.x;\n  const top = headNode.y - EDGE_HEIGHT / 2;\n  const width = getDistance(\n    headNode.x,\n    headNode.y,\n    tailPosition.x,\n    tailPosition.y\n  );\n  const degree = getAngleRad(\n    headNode.x,\n    headNode.y,\n    tailPosition.x,\n    tailPosition.y\n  );\n\n  return (\n    <StyledGhostEdge left={left} top={top} width={width} degree={degree} />\n  );\n};\n\nexport default GhostEdge;\n","import GhostEdge from \"./GhostEdge\";\nimport * as GhostEdgeModules from \"./GhostEdge\";\n\nexport type GhostEdgeProps = GhostEdgeModules.GhostEdgeProps;\nexport default GhostEdge;\n","import { useCallback, useReducer, useState } from \"react\";\nimport { pan, zoom } from \"helper\";\n\nimport { TransformState } from \"Interfaces/TransformState\";\nimport { PanProps } from \"Interfaces/PanProps\";\nimport { ZoomProps } from \"Interfaces/ZoomProps\";\nimport { ScaleProps } from \"Interfaces/ScaleProps\";\n\ntype Action =\n  | { type: \"PAN\"; props: PanProps }\n  | { type: \"ZOOM\"; props: ZoomProps; scale: ScaleProps };\n\nconst initialState: TransformState = {\n  offsetX: 0,\n  offsetY: 0,\n  scale: 1,\n};\n\n// TODO: Fix\nconst MENUBAR_OFFSET = 97;\n\n// TODO: How to reconfigure transformOrigin on zoomout\nconst isStateValid = (state: TransformState): boolean => {\n  const worldSpaceWidth = window.innerWidth * state.scale;\n  const worldSpaceHeight = (window.innerHeight - MENUBAR_OFFSET) * state.scale;\n  if (\n    state.offsetX > 0 ||\n    state.offsetY > 0 ||\n    Math.abs(state.offsetX) * state.scale >\n      worldSpaceWidth - window.innerWidth ||\n    Math.abs(state.offsetY) * state.scale >\n      worldSpaceHeight - (window.innerHeight - MENUBAR_OFFSET)\n  ) {\n    return false;\n  } else {\n    return true;\n  }\n};\n\nconst transformReducer = (\n  state: TransformState,\n  action: Action\n): TransformState => {\n  switch (action.type) {\n    case \"PAN\":\n      const newStateFromPan = pan(state, action.props);\n      return isStateValid(newStateFromPan) ? newStateFromPan : state;\n    case \"ZOOM\":\n      const newStateFromZoom = zoom(state, action.props, action.scale);\n      return isStateValid(newStateFromZoom) ? newStateFromZoom : state;\n    default:\n      throw new Error();\n  }\n};\n\nexport const useTransformation = (scaleProps: ScaleProps) => {\n  const [state, dispatch] = useReducer(transformReducer, initialState);\n\n  const usePan = useCallback(\n    (panProps: PanProps): void => dispatch({ type: \"PAN\", props: panProps }),\n    [dispatch, scaleProps]\n  );\n\n  const useZoom = useCallback(\n    (zoomProps: ZoomProps): void =>\n      dispatch({ type: \"ZOOM\", props: zoomProps, scale: scaleProps }),\n    [dispatch, scaleProps]\n  );\n\n  return { transformState: state, pan: usePan, zoom: useZoom };\n};\n","class PQNode<K, V> {\n  key: K;\n  priority: V;\n  left: PQNode<K, V> | null;\n  right: PQNode<K, V> | null;\n  parent: PQNode<K, V> | null;\n\n  constructor(item: K, value: V) {\n    this.key = item;\n    this.priority = value;\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n  }\n\n  isLeaf() {\n    return this.left === null && this.right === null;\n  }\n\n  isRoot() {\n    return this.parent === null;\n  }\n\n  isLeftChild() {\n    if (this.isRoot()) {\n      return false;\n    }\n    return this.parent!.left === this;\n  }\n\n  isRightChild() {\n    if (this.isRoot()) {\n      return false;\n    }\n    return this.parent!.right === this;\n  }\n}\n\nexport default PQNode;\n","import PQNode from \"Classes/PQNode\";\n\nclass PriorityQueue<K, V> {\n  root: null | PQNode<K, V>;\n  lastAdded: null | PQNode<K, V>;\n  keyToNode: Map<K, PQNode<K, V>>;\n\n  constructor() {\n    // Initialize private properties\n    this.root = null;\n    this.lastAdded = null;\n    this.keyToNode = new Map<K, PQNode<K, V>>(); //vertex to PQNode\n  }\n\n  private swap(child: PQNode<K, V>, parent: PQNode<K, V>) {\n    let tempKey = child.key;\n    let tempPriority = child.priority;\n    child.key = parent.key;\n    child.priority = parent.priority;\n    parent.key = tempKey;\n    parent.priority = tempPriority;\n    this.keyToNode.set(parent.key, parent);\n    this.keyToNode.set(child.key, child);\n  }\n\n  // Swaps key and value upward from insertion node\n  // O(log n): heap height == log n\n  // Only called when 'node' is not root\n  private upheap(node: PQNode<K, V>) {\n    let currNode = node;\n    let parent = currNode.parent;\n\n    while (currNode.priority < parent!.priority) {\n      this.swap(currNode, parent!);\n      if (parent!.isRoot()) {\n        return;\n      }\n      currNode = parent!;\n      parent = parent!.parent;\n    }\n  }\n\n  // Swaps key and value downward from the root\n  // O(log n): heap height == log n\n  private downheap(node: PQNode<K, V>) {\n    let currNode = node;\n\n    while (currNode.isLeaf() === false) {\n      // Choose smaller of children to swap and downheap\n      let childNode =\n        currNode.right === null ||\n        currNode.left!.priority < currNode.right.priority\n          ? currNode.left\n          : currNode.right;\n      if (childNode!.priority >= currNode.priority) {\n        return;\n      } else {\n        this.swap(childNode!, currNode);\n        currNode = childNode!;\n      }\n    }\n  }\n\n  // Inserts given node to its insertion node position\n  // Finding the insertion node - O(log n)\n  private insert(newNode: PQNode<K, V>) {\n    // Recursively go up until left child or root is reached\n    let currNode = this.lastAdded;\n\n    while (currNode!.isRoot() === false && currNode!.isLeftChild() === false) {\n      currNode = currNode!.parent;\n    }\n    // If left child, find sibling\n    if (currNode!.isLeftChild()) {\n      let parent = currNode!.parent;\n      let sibling = parent!.right;\n      // Case 1: If sibling is empty, insert here\n      if (sibling === null) {\n        parent!.right = newNode;\n        newNode.parent = parent;\n        this.lastAdded = newNode;\n        return;\n      } else {\n        // Case 2: If sibling exists, start from sibling\n        currNode = sibling;\n      }\n    }\n    // Keep going down left until leaf, and insert as left child\n    while (currNode!.isLeaf() === false) {\n      currNode = currNode!.left;\n    }\n    currNode!.left = newNode;\n    newNode.parent = currNode;\n    this.lastAdded = newNode;\n  }\n\n  public decreaseKey(key: K, priority: V) {\n    let node = this.keyToNode.get(key);\n    if (node === undefined) return;\n\n    node.priority = priority;\n    if (node.isRoot() === false) {\n      this.upheap(node);\n    }\n  }\n\n  public enqueue(key: K, priority: V) {\n    if (key === null || priority === null) {\n      return;\n    }\n    const newNode = new PQNode(key, priority);\n    if (this.root === null) {\n      this.root = newNode;\n      this.lastAdded = newNode;\n      this.keyToNode.set(key, newNode);\n    } else {\n      this.insert(newNode);\n      this.keyToNode.set(key, newNode);\n      this.upheap(this.lastAdded!);\n    }\n  }\n\n  // Removes item with the lowest priority (i.e. root)\n  public dequeue() {\n    if (this.isEmpty()) return null;\n\n    if (this.root === this.lastAdded) {\n      let key = this.root!.key;\n      this.root = null;\n      this.lastAdded = null;\n      this.keyToNode.delete(key);\n      return key;\n    }\n\n    // 1. Swap root priority and value with last element\n    this.swap(this.root!, this.lastAdded!);\n\n    // 2. Remove last element\n    let key = this.lastAdded!.key;\n    this.keyToNode.delete(key);\n\n    if (this.lastAdded!.isLeftChild()) {\n      // Prune last added element\n      let currNode = this.lastAdded!.parent;\n      currNode!.left = null;\n\n      // Update last added element\n      while (\n        currNode!.isRoot() === false &&\n        currNode!.isRightChild() === false\n      ) {\n        currNode = currNode!.parent;\n      }\n      if (currNode!.isRightChild()) {\n        let sibling = currNode!.parent!.left;\n        currNode = sibling;\n      }\n      while (currNode!.isLeaf() === false) {\n        currNode = currNode!.right;\n      }\n      this.lastAdded = currNode;\n    } else {\n      this.lastAdded!.parent!.right = null;\n      this.lastAdded = this.lastAdded!.parent!.left;\n    }\n\n    // 3. Down heap to maintain heap order\n    this.downheap(this.root!);\n    return key;\n  }\n\n  public containsKey(key: K) {\n    return this.keyToNode.has(key);\n  }\n\n  public isEmpty() {\n    return this.root === null;\n  }\n}\n\nexport default PriorityQueue;\n","import PQNode from \"Classes/PQNode\";\nimport PriorityQueue from \"Classes/PriorityQueue\";\nimport { VertexInterface } from \"Interfaces/VertexInterface\";\nimport { EdgeInterface } from \"Interfaces/EdgeInterface\";\nimport { getDistance } from \"helper\";\nimport { Edge } from \"Components/App/Container/Canvas\";\n\n/********** OUTPUT TYPES **********/\nexport type Tuple<T, N> = [T, N];\nexport type PathOutput = Tuple<EdgeInterface[], EdgeInterface[]>;\nexport type MaxFlowOutput = Tuple<Tuple<EdgeInterface, number>[], number>;\n\n/********** HELPER FUNCTIONS **********/\n\nfunction getPathToNode(\n  node: VertexInterface,\n  edges: EdgeInterface[]\n): EdgeInterface[] {\n  const path: EdgeInterface[] = [];\n  let prev: VertexInterface | null = node.prev;\n  let curr: VertexInterface = node;\n  while (prev !== null) {\n    let edge = edges.find(\n      (edge) => edge.headNode === prev && edge.tailNode === curr\n    );\n    path.unshift(edge!);\n    curr = prev;\n    prev = curr.prev;\n  }\n  return path;\n}\n\n// Path compression and parent lookup\nfunction findRoot(\n  node: VertexInterface,\n  parent: Map<VertexInterface, VertexInterface>\n) {\n  if (parent.get(node) !== node) {\n    parent.set(node, findRoot(parent.get(node)!, parent));\n  }\n  return parent.get(node)!;\n}\n\n// union-find for Kruskal's\nfunction merge(\n  u: VertexInterface,\n  v: VertexInterface,\n  parent: Map<VertexInterface, VertexInterface>,\n  rank: Map<VertexInterface, number>\n) {\n  const uParent = findRoot(u, parent)!;\n  const vParent = findRoot(v, parent)!;\n  const uRank = rank.get(uParent)!;\n  const vRank = rank.get(vParent)!;\n\n  // Point v cloud to u cloud\n  if (uRank > vRank) {\n    parent.set(vParent, uParent);\n    rank.set(uParent, uRank + 1);\n  } else {\n    parent.set(uParent, vParent);\n    rank.set(vParent, vRank + 1);\n  }\n}\n\ninterface ResidualGraphEdge extends EdgeInterface {\n  capacity: number;\n  isReverse: boolean;\n}\n\nfunction findAugmentingPath(\n  vertices: Array<VertexInterface>,\n  edges: Array<ResidualGraphEdge>,\n  source: VertexInterface,\n  sink: VertexInterface\n) {\n  const visited: VertexInterface[] = [];\n  const queue: VertexInterface[] = [];\n  queue.push(source);\n  visited.push(source);\n\n  while (queue.length) {\n    const u = queue.shift()!;\n    const outEdges = edges.filter((e) => {\n      return e.headNode === u && e.capacity > 0;\n    });\n\n    for (let i = 0; i < outEdges.length; i++) {\n      const neighbor = outEdges[i].tailNode;\n      if (!visited.includes(neighbor)) {\n        queue.push(neighbor);\n        visited.push(neighbor);\n        neighbor.prev = u;\n      }\n    }\n  }\n  return visited.includes(sink);\n}\n\nfunction getResidualGraph(V: Array<VertexInterface>, E: Array<EdgeInterface>) {\n  // Decorate edges with capacity and isReverse boolean\n  const residualEdges: ResidualGraphEdge[] = [];\n  E.forEach((edge) =>\n    residualEdges.push({ ...edge, capacity: edge.weight, isReverse: false })\n  );\n\n  // Add reverse edges to residual graph's edges\n  E.forEach((edge) => {\n    const reverseHead = edge.tailNode;\n    const reverseTail = edge.headNode;\n    residualEdges.push({\n      ...edge,\n      headNode: reverseHead,\n      tailNode: reverseTail,\n      capacity: 0,\n      isReverse: true,\n    });\n  });\n\n  return { V: V, E: residualEdges };\n}\n\nexport function getConnectedComponents(\n  vertices: Array<VertexInterface>,\n  edges: Array<EdgeInterface>\n) {\n  const cc = new Map<VertexInterface, number>();\n  const visited = new Set<VertexInterface>();\n\n  let ccNum = 0;\n  vertices.forEach((v) => {\n    if (!visited.has(v)) {\n      ccNum++;\n      explore(v, edges, visited, cc, ccNum);\n    }\n  });\n\n  return cc;\n}\n\nfunction explore(\n  v: VertexInterface,\n  E: Array<EdgeInterface>,\n  visited: Set<VertexInterface>,\n  cc: Map<VertexInterface, number>,\n  ccNum: number\n) {\n  visited.add(v);\n  cc.set(v, ccNum);\n  const incidentEdges = E.filter((e) => e.headNode === v || e.tailNode === v);\n\n  incidentEdges.forEach((e) => {\n    let neighbor = e.headNode === v ? e.tailNode : e.headNode;\n    if (!visited.has(neighbor)) {\n      explore(neighbor, E, visited, cc, ccNum);\n    }\n  });\n}\n\n/********** PATH-FINDING ALGORITHMS **********/\n// Output: EdgeInterface[][]; tuple\n\nexport function dijkstra(\n  vertices: Array<VertexInterface>,\n  edges: Array<EdgeInterface>,\n  source: VertexInterface,\n  target: VertexInterface\n): PathOutput {\n  for (const v of vertices) {\n    v.dist = Infinity;\n    v.prev = null;\n  }\n  source.dist = 0; // Distance from source to itself\n\n  const PQ = new PriorityQueue<VertexInterface, number>();\n  for (const v of vertices) PQ.enqueue(v, v.dist);\n\n  const traversed: Array<EdgeInterface> = [];\n\n  while (PQ.isEmpty() === false) {\n    const u = PQ.dequeue();\n    if (u === target) {\n      break;\n    } else {\n      const outgoingEdges = edges.filter((e) => e.headNode === u);\n      for (const edge of outgoingEdges) {\n        traversed.push(edge);\n        const v = edge.tailNode;\n        let uvDist = u!.dist + edge.weight;\n        if (uvDist < v.dist) {\n          v.dist = uvDist;\n          v.prev = u; // Maintain pointers for path\n          PQ.decreaseKey(v, v.dist);\n        }\n      }\n    }\n  }\n  const shortestPath = getPathToNode(target, edges);\n  return [traversed, shortestPath];\n}\n\nexport function dfs(\n  vertices: Array<VertexInterface>,\n  edges: Array<EdgeInterface>,\n  source: VertexInterface,\n  target: VertexInterface\n): PathOutput {\n  const stack: VertexInterface[] = [];\n  const visited: VertexInterface[] = [];\n  const traversed: EdgeInterface[] = [];\n  let path: EdgeInterface[] = [];\n\n  for (const v of vertices) {\n    v.prev = null;\n  }\n\n  stack.push(source);\n  while (stack.length) {\n    let node: VertexInterface = stack.pop()!;\n    visited.push(node);\n\n    if (node.prev) {\n      const inEdge = edges.find(\n        (edge) => edge.headNode === node.prev && edge.tailNode === node\n      )!;\n      traversed.push(inEdge);\n    }\n\n    if (node === target) {\n      path = getPathToNode(node, edges);\n      break;\n    }\n\n    let outEdges = edges.filter((edge) => edge.headNode === node);\n    for (const edge of outEdges) {\n      if (!visited.includes(edge.tailNode)) {\n        edge.tailNode.prev = node;\n        stack.push(edge.tailNode);\n      }\n    }\n  }\n  return [traversed, path];\n}\n\nexport function bfs(\n  vertices: Array<VertexInterface>,\n  edges: Array<EdgeInterface>,\n  source: VertexInterface,\n  target: VertexInterface\n): PathOutput {\n  const queue: VertexInterface[] = [];\n  const visited: VertexInterface[] = [];\n  const traversed: EdgeInterface[] = [];\n  let path: EdgeInterface[] = [];\n\n  for (const v of vertices) {\n    v.prev = null;\n  }\n\n  queue.push(source);\n  while (queue.length) {\n    let node: VertexInterface = queue.shift()!;\n    visited.push(node);\n\n    if (node.prev) {\n      const inEdge = edges.find(\n        (edge) => edge.headNode === node.prev && edge.tailNode === node\n      )!;\n      traversed.push(inEdge);\n    }\n\n    if (node === target) {\n      path = getPathToNode(node, edges);\n      break;\n    }\n\n    let outEdges = edges.filter((edge) => edge.headNode === node);\n    for (const edge of outEdges) {\n      if (!visited.includes(edge.tailNode)) {\n        edge.tailNode.prev = node;\n        queue.push(edge.tailNode);\n      }\n    }\n  }\n  return [traversed, path];\n}\n\nexport function aStar(\n  vertices: Array<VertexInterface>,\n  edges: Array<EdgeInterface>,\n  source: VertexInterface,\n  target: VertexInterface,\n  heuristic: Map<VertexInterface, number>\n): PathOutput {\n  for (const v of vertices) {\n    v.dist = Infinity;\n    v.prev = null;\n  }\n  source.dist = 0; // Distance from source to itself\n\n  const PQ = new PriorityQueue<VertexInterface, number>();\n  for (const v of vertices) PQ.enqueue(v, heuristic.get(v)! + v.dist);\n\n  const traversed: Array<EdgeInterface> = [];\n\n  while (PQ.isEmpty() === false) {\n    const u = PQ.dequeue();\n\n    if (u == target) {\n      break;\n    } else {\n      const outgoingEdges = edges.filter((e) => e.headNode === u);\n      for (const edge of outgoingEdges) {\n        traversed.push(edge);\n        const v = edge.tailNode;\n        let uvDist = u!.dist + edge.weight;\n        if (uvDist < v.dist) {\n          v.dist = uvDist;\n          v.prev = u; // Maintain pointers for path\n          PQ.decreaseKey(v, heuristic.get(v)! + v.dist);\n        }\n      }\n    }\n  }\n  const shortestPath = getPathToNode(target, edges);\n  return [traversed, shortestPath];\n}\n\nexport function bellmanFord(\n  vertices: Array<VertexInterface>,\n  edges: Array<EdgeInterface>,\n  source: VertexInterface,\n  target: VertexInterface,\n  heuristic: Map<VertexInterface, number>\n) {\n  const traversed: EdgeInterface[] = [];\n  let path: EdgeInterface[] = [];\n\n  for (const v of vertices) {\n    v.dist = Infinity;\n    v.prev = null;\n  }\n  source.dist = 0; // Distance from source to itself\n  let relaxed = null;\n\n  for (let i = 0; i < vertices.length - 1; i++) {\n    if (relaxed !== null && !relaxed) break;\n    else {\n      relaxed = false;\n      for (const edge of edges) {\n        traversed.push(edge);\n        const u = edge.headNode;\n        const v = edge.tailNode;\n        let uvDist = u!.dist + edge.weight;\n        if (uvDist < v.dist) {\n          relaxed = true;\n          v.dist = uvDist;\n          v.prev = u; // Maintain pointers for path\n        }\n      }\n    }\n  }\n  const shortestPath = getPathToNode(target, edges);\n  return [traversed, shortestPath];\n}\n\n/********** SPANNING TREE ALGORITHMS **********/\n\nexport function prim(\n  vertices: Array<VertexInterface>,\n  edges: Array<EdgeInterface>,\n  source: VertexInterface\n): PathOutput {\n  for (const v of vertices) {\n    v.dist = Infinity;\n    v.prev = null;\n  }\n  source.dist = 0;\n\n  const traversed: EdgeInterface[] = [];\n  const mst: EdgeInterface[] = [];\n\n  const PQ = new PriorityQueue<VertexInterface, number>();\n  for (const v of vertices) PQ.enqueue(v, v.dist);\n\n  while (!PQ.isEmpty()) {\n    const u = PQ.dequeue()!;\n    console.log(u.dist);\n    if (u.prev !== null) {\n      const edge = edges.find(\n        (edge) =>\n          (edge.headNode === u.prev && edge.tailNode === u) ||\n          (edge.tailNode === u.prev && edge.headNode === u)\n      );\n      mst.push(edge!);\n      traversed.push(edge!);\n    }\n\n    const incidentEdges = edges.filter((e) => {\n      if (\n        (e.headNode === u && PQ.containsKey(e.tailNode)) ||\n        (e.tailNode === u && PQ.containsKey(e.headNode))\n      ) {\n        return e;\n      } else if (\n        ((e.headNode === u && !PQ.containsKey(e.tailNode)) ||\n          (e.tailNode === u && !PQ.containsKey(e.headNode))) &&\n        !traversed.includes(e)\n      ) {\n        traversed.push(e);\n      }\n    });\n    for (const edge of incidentEdges) {\n      const v = edge.headNode === u ? edge.tailNode : edge.headNode;\n      let uvWeight = edge.weight;\n      if (uvWeight < v.dist) {\n        v.dist = uvWeight;\n        v.prev = u; // Maintain pointers for path\n        PQ.decreaseKey(v, v.dist);\n      }\n    }\n  }\n\n  return [traversed, mst];\n}\n\nexport function kruskal(\n  vertices: Array<VertexInterface>,\n  edges: Array<EdgeInterface>,\n  source: VertexInterface\n): PathOutput {\n  const sortedEdges = edges.sort((e1, e2) => (e1.weight < e2.weight ? -1 : 1));\n  const parent = new Map<VertexInterface, VertexInterface>();\n  const rank = new Map<VertexInterface, number>();\n\n  vertices.forEach((vertex) => {\n    parent.set(vertex, vertex);\n    rank.set(vertex, 0);\n  });\n\n  const traversed: EdgeInterface[] = [];\n  const mst: EdgeInterface[] = [];\n  for (const edge of sortedEdges) {\n    const u = edge.headNode;\n    const v = edge.tailNode;\n    if (findRoot(u, parent) !== findRoot(v, parent)) {\n      mst.push(edge);\n      merge(u, v, parent, rank);\n    }\n    traversed.push(edge);\n  }\n  return [traversed, mst];\n}\n\n/********** MAX-FLOW ALGORITHMS **********/\n\nexport function fulkerson(\n  vertices: Array<VertexInterface>,\n  edges: Array<EdgeInterface>,\n  source: VertexInterface,\n  sink: VertexInterface\n): MaxFlowOutput {\n  const { V: residualV, E: residualE } = getResidualGraph(vertices, edges);\n  let maxFlow = 0;\n  let traversed: Tuple<EdgeInterface, number>[] = [];\n\n  // while path exists from source to sink, augment flow\n  while (findAugmentingPath(residualV, residualE, source, sink)) {\n    let pathFlow = Infinity;\n    let s = sink;\n    // find maximum flow through this path\n    while (s !== source) {\n      let edge = residualE.find(\n        (e) => e.headNode === s.prev && e.tailNode === s\n      );\n      pathFlow = Math.min(pathFlow, edge!.capacity); // amount of flow constrained by edge with least capacity\n      s = s.prev!;\n    }\n    maxFlow += pathFlow;\n\n    let v = sink;\n    // update residual capacities of edges and backwards edges in path\n    let path: Tuple<EdgeInterface, number>[] = [];\n    while (v !== source) {\n      let u = v.prev;\n      let residualForwardEdge = residualE.find(\n        (e) => e.headNode === u && e.tailNode === v && e.isReverse === false\n      )!;\n      let residualBackwardEdge = residualE.find(\n        (e) => e.tailNode === u && e.headNode === v && e.isReverse === true\n      )!;\n      residualForwardEdge.capacity -= pathFlow;\n      residualBackwardEdge.capacity += pathFlow;\n      v = v.prev!;\n\n      let edgeFlow = residualForwardEdge.weight - residualForwardEdge.capacity;\n      //let saturation = edgeFlow / residualForwardEdge.weight;\n      let realEdge = edges.find(\n        (e) =>\n          e.headNode === residualForwardEdge.headNode &&\n          e.tailNode === residualForwardEdge.tailNode\n      )!;\n      path.unshift([realEdge, edgeFlow]);\n    }\n    traversed = [...traversed, ...path];\n  }\n  return [traversed, maxFlow];\n}\n","import { useState, useEffect } from \"react\";\n\nimport { useAlgoState } from \"Contexts/AlgorithmContext\";\nimport { Node, Edge } from \"Components/App/Container/Canvas\";\nimport { getConnectedComponents, dijkstra, dfs, bfs, aStar } from \"algorithms\";\nimport {\n  prim,\n  kruskal,\n  fulkerson,\n  PathOutput,\n  MaxFlowOutput,\n} from \"algorithms\";\nimport { EdgeInterface } from \"Interfaces/EdgeInterface\";\nimport { VertexInterface } from \"Interfaces/VertexInterface\";\nimport { getDistance } from \"helper\";\n\nexport const useAlgorithms = () => {\n  const [source, setSource] = useState<Node | null>(null);\n  const [target, setTarget] = useState<Node | null>(null);\n  const algoState = useAlgoState();\n\n  const setSourceNode = (node: Node | null) => {\n    setSource(node);\n  };\n\n  const setTargetNode = (node: Node | null) => {\n    setTarget(node);\n  };\n\n  const getHeuristic = (nodes: Node[], target: Node) => {\n    const heuristic = new Map<VertexInterface, number>();\n    for (const node of nodes) {\n      const dist = getDistance(node.x, node.y, target.x, target.y);\n      heuristic.set(node, dist);\n    }\n    return heuristic;\n  };\n\n  const runPathAlgorithm = (\n    algorithm: string,\n    nodes: Node[],\n    edges: Edge[]\n  ): PathOutput => {\n    switch (algorithm) {\n      case \"dijkstra\":\n        return dijkstra(nodes, edges, source!, target!);\n      case \"dfs\":\n        return dfs(nodes, edges, source!, target!);\n      case \"bfs\":\n        return bfs(nodes, edges, source!, target!);\n      case \"a*\":\n        const heuristic = getHeuristic(nodes, target!);\n        return aStar(nodes, edges, source!, target!, heuristic);\n      default:\n        throw new Error();\n    }\n  };\n\n  const runTreeAlgorithm = (\n    algorithm: string,\n    nodes: Node[],\n    edges: Edge[]\n  ): PathOutput => {\n    switch (algorithm) {\n      case \"prim\":\n        return prim(nodes, edges, source!);\n      case \"kruskal\":\n        return kruskal(nodes, edges, source!);\n      default:\n        throw new Error();\n    }\n  };\n\n  const runFlowAlgorithm = (\n    algorithm: string,\n    nodes: Node[],\n    edges: Edge[]\n  ): MaxFlowOutput => {\n    switch (algorithm) {\n      case \"fulkerson\":\n        return fulkerson(nodes, edges, source!, target!);\n      default:\n        throw new Error();\n    }\n  };\n\n  function checkConnectedComponents(\n    V: VertexInterface[],\n    E: EdgeInterface[],\n    v: VertexInterface,\n    u: VertexInterface\n  ) {\n    const cc = getConnectedComponents(V, E);\n    return cc.get(v) === cc.get(u) ? true : false;\n  }\n\n  useEffect(() => {\n    if (algoState.name === null) {\n      setSource(null);\n      setTarget(null);\n    }\n  }, [algoState, setSource, setTarget]);\n\n  return {\n    setSourceNode,\n    setTargetNode,\n    source,\n    target,\n    runPathAlgorithm,\n    runTreeAlgorithm,\n    runFlowAlgorithm,\n    checkConnectedComponents,\n  };\n};\n","import React, { useState, useRef, useEffect } from \"react\";\nimport styled from \"styled-components\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nimport GraphNode from \"./GraphNode\";\nimport GraphEdge from \"./GraphEdge\";\nimport GhostEdge, { GhostEdgeProps } from \"./GhostEdge\";\n\nimport { useTransformation } from \"Hooks/useTransformation\";\nimport { useAlgorithms } from \"Hooks/useAlgorithms\";\nimport { useAlgoState, useAlgoDispatch } from \"Contexts/AlgorithmContext\";\nimport { useKeyState } from \"Contexts/KeyContext\";\nimport { screenToWorld, getDistance } from \"helper\";\n\nimport { VertexInterface } from \"Interfaces/VertexInterface\";\nimport { EdgeInterface } from \"Interfaces/EdgeInterface\";\n\nimport { Tuple, PathOutput, MaxFlowOutput } from \"algorithms\";\n\ninterface CanvasProps {\n  clearGraphs: boolean;\n  offClear: () => void;\n  speed: number;\n}\n\n// TODO: Fix\nconst MENUBAR_OFFSET = 97;\n\nconst StyledDiv = styled.div`\n  flex: 9;\n  background: #16213e;\n  position: relative;\n  z-index: 1;\n  height: 100%;\n  width: 100%;\n`;\n\n// Configuration for scaling\nconst scaleProps = {\n  minScale: 1,\n  maxScale: 20,\n  scaleSensitivity: 10,\n};\n\nexport interface Node extends VertexInterface {\n  id: string;\n  x: number;\n  y: number;\n  outEdgeIDs: string[];\n  inEdgeIDs: string[];\n}\n\nexport interface Edge extends EdgeInterface {\n  id: string;\n  headNode: Node;\n  tailNode: Node;\n  animation: string | null;\n  optionalValue: number;\n}\n\nconst Canvas: React.FC<CanvasProps> = ({ clearGraphs, offClear, speed }) => {\n  const [nodes, setNodes] = useState<Array<Node>>([]);\n  const [edges, setEdges] = useState<Array<Edge>>([]);\n  const [ghostEdge, setGhostEdge] = useState<GhostEdgeProps | null>(null);\n\n  const mouseIsHeld = useRef<boolean>(false);\n  const mouseMoved = useRef<boolean>(false);\n\n  const mouseDownNode = useRef<Node | null>(null);\n  const isMovingNode = useRef<boolean>(false);\n  const dKeyPressed = useRef<boolean>(false); //TODO: only works when canvas is clicked\n\n  const keyState = useKeyState();\n  const [showLabel, setShowLabel] = useState<boolean>(false);\n\n  useEffect(() => {\n    if (keyState.key === \"w\" && keyState.isPressed) {\n      setShowLabel((show) => !show);\n    }\n  }, [keyState, setShowLabel]);\n\n  const algoState = useAlgoState();\n  const algoDispatch = useAlgoDispatch();\n  const { transformState, pan, zoom } = useTransformation(scaleProps);\n  const {\n    source,\n    target,\n    setSourceNode,\n    setTargetNode,\n    runPathAlgorithm,\n    runTreeAlgorithm,\n    runFlowAlgorithm,\n    checkConnectedComponents,\n  } = useAlgorithms();\n\n  useEffect(() => {\n    for (let i = 0; i < 20; i++) {\n      zoom({\n        pageX: window.innerWidth / 2,\n        pageY: (window.innerHeight - MENUBAR_OFFSET) / 2,\n        delta: 1,\n      });\n    }\n    return;\n  }, []);\n\n  const timer = useRef<number | null>(null);\n  const index = useRef<number>(0);\n  const interval = useRef<number>(1000);\n  const algoOutput = useRef<\n    EdgeInterface[] | Tuple<EdgeInterface, number>[] | null\n  >(null);\n  const algoPath = useRef<EdgeInterface[] | null>(null);\n  const maxFlowOutput = useRef<number>(0);\n  const prevFlow = useRef<number>(0);\n\n  function setEdgeAnimation(\n    animation: string | null,\n    edge: EdgeInterface,\n    optional: number = 0\n  ) {\n    setEdges((E) =>\n      E.map((e) => {\n        if (e === edge) {\n          e.animation = animation;\n          if (algoState.category === \"flow\") e.optionalValue = optional;\n        }\n        return e;\n      })\n    );\n  }\n\n  function resetAllEdgeAnimation() {\n    setEdges((E) =>\n      E.map((e) => {\n        e.animation = null;\n        e.optionalValue = 0;\n        return e;\n      })\n    );\n  }\n\n  useEffect(() => {\n    interval.current = 1000 / speed;\n    // async function test() {\n    //   await algoDispatch({ type: \"pause\" });\n    //   algoDispatch({ type: \"continue\" });\n    // }\n    if (algoState.status === \"running\") {\n      algoDispatch({ type: \"pause\" });\n      algoDispatch({ type: \"continue\" });\n    }\n  }, [speed]);\n\n  function visualizePath(\n    array: EdgeInterface[],\n    targetPath: EdgeInterface[]\n  ): void {\n    timer.current = setTimeout(() => {\n      if (index.current < array.length) {\n        let edge = array[index.current];\n        setEdgeAnimation(\"regular\", edge);\n        index.current = index.current + 1;\n        visualizePath(array, targetPath);\n      } else {\n        let length = 0;\n        targetPath.forEach((edge) => {\n          setEdgeAnimation(\"special\", edge);\n          length += edge.weight;\n        });\n        algoDispatch({ type: \"complete\", newValue: `Length: ${length}` });\n        clearTimeout(timer.current!);\n        index.current = 0;\n      }\n    }, interval.current);\n  }\n\n  function visualizeMST(array: EdgeInterface[], targetPath: EdgeInterface[]) {\n    timer.current = setTimeout(() => {\n      if (index.current < array.length) {\n        let edge = array[index.current];\n        if (targetPath.includes(edge)) {\n          setEdgeAnimation(\"special\", edge);\n        } else {\n          setEdgeAnimation(\"regular\", edge);\n        }\n        index.current = index.current + 1;\n        visualizeMST(array, targetPath);\n      } else {\n        let weight = 0;\n        targetPath.forEach((edge) => (weight += edge.weight));\n        algoDispatch({ type: \"complete\", newValue: `Weight: ${weight}` });\n        clearTimeout(timer.current!);\n        index.current = 0;\n      }\n    }, interval.current);\n  }\n\n  function visualizeMaxFlow(\n    traversed: Tuple<EdgeInterface, number>[],\n    maxFlow: number\n  ) {\n    timer.current = setTimeout(() => {\n      if (index.current < traversed.length) {\n        let [edge, flow] = traversed[index.current];\n        const curr = edges.find((e) => e === edge)!;\n        prevFlow.current = curr.optionalValue;\n\n        setEdgeAnimation(\"regular\", edge, flow);\n        index.current = index.current + 1;\n        visualizeMaxFlow(traversed, maxFlow);\n      } else {\n        algoDispatch({ type: \"complete\", newValue: `Max-Flow: ${maxFlow}` });\n        clearTimeout(timer.current!);\n        index.current = 0;\n      }\n    }, interval.current);\n  }\n\n  function stepAlgorithmForward() {\n    if (index.current < algoOutput.current!.length) {\n      // Simply step forward if algorithm has not completed\n      //let edge: EdgeInterface | Tuple<EdgeInterface, number> | null;\n      if (algoState.category === \"path\") {\n        let edge = algoOutput.current![index.current] as EdgeInterface;\n        setEdgeAnimation(\"regular\", edge);\n      }\n      if (algoState.category === \"tree\") {\n        let edge = algoOutput.current![index.current] as EdgeInterface;\n        if (algoPath.current!.includes(edge)) {\n          setEdgeAnimation(\"special\", edge);\n        } else {\n          setEdgeAnimation(\"regular\", edge);\n        }\n      }\n      if (algoState.category === \"flow\") {\n        let output = algoOutput.current![index.current];\n        let [edge, flow] = output as Tuple<EdgeInterface, number>;\n        const curr = edges.find((e) => e === edge)!;\n        prevFlow.current = curr.optionalValue;\n        setEdgeAnimation(\"regular\", edge, flow);\n      }\n      index.current = index.current + 1;\n      algoDispatch({ type: \"pause\" });\n    } else {\n      // Otherwise, dispatch complete\n      if (algoState.category === \"path\") {\n        let length = 0;\n        algoPath.current!.forEach((edge) => {\n          length += edge.weight;\n          setEdgeAnimation(\"special\", edge);\n        });\n\n        algoDispatch({ type: \"complete\", newValue: `Distance: ${length}` });\n      }\n      if (algoState.category === \"tree\") {\n        let weight = 0;\n        algoPath.current!.forEach((edge) => (weight += edge.weight));\n        algoDispatch({ type: \"complete\", newValue: `Weight: ${weight}` });\n      }\n      if (algoState.category === \"flow\") {\n        algoDispatch({\n          type: \"complete\",\n          newValue: `Max-Flow: ${maxFlowOutput.current}`,\n        });\n      }\n      clearTimeout(timer.current!);\n      index.current = 0;\n    }\n  }\n\n  function stepAlgorithmBackward() {\n    if (index.current === 0) {\n      algoDispatch({\n        type: \"setStatus\",\n        newStatus: \"ready\",\n        ready: true,\n      });\n      return;\n    }\n\n    if (algoState.status !== \"completed\") {\n      // Simply step back if algorithm has not completed\n      if (algoOutput.current !== null) {\n        if (algoState.category === \"path\" || algoState.category === \"tree\") {\n          let edge = algoOutput.current[index.current - 1] as EdgeInterface;\n          setEdgeAnimation(null, edge);\n        }\n        if (algoState.category === \"flow\") {\n          let output = algoOutput.current[index.current - 1];\n          let [edge, flow] = output as Tuple<EdgeInterface, number>;\n\n          let oldFlow = 0;\n          for (let i = 0; i < index.current - 1; i++) {\n            let [tempEdge, tempFlow] = algoOutput.current[i] as Tuple<\n              EdgeInterface,\n              number\n            >;\n            if (tempEdge === edge) oldFlow = tempFlow;\n          }\n          prevFlow.current = oldFlow;\n          setEdgeAnimation(null, edge, prevFlow.current); //first instance before current one\n        }\n        algoDispatch({ type: \"pause\" });\n      }\n    }\n\n    if (index.current === 0) {\n      algoDispatch({\n        type: \"setStatus\",\n        newStatus: \"ready\",\n        ready: true,\n      });\n    } else {\n      index.current = index.current - 1;\n    }\n    //else {\n    //   // Otherwise get rid of the special animation for completed edges\n    //   if (algoState.category === \"path\" || algoState.category === \"tree\") {\n    //     algoPath.current!.forEach((edge) => setEdgeAnimation(\"regular\", edge));\n    //     index.current = algoOutput.current!.length;\n    //   }\n    //   if (algoState.category === \"flow\") {\n    //     //bc no special effect for flow\n    //     let output = algoOutput.current![index.current];\n    //     let [edge, saturation] = output as Tuple<EdgeInterface, number>;\n    //     setEdgeAnimation(null, edge, saturation);\n    //     index.current = index.current - 1;\n    //   }\n    //   algoDispatch({ type: \"pause\" });\n    // }\n  }\n\n  useEffect(() => {\n    switch (algoState.status) {\n      case \"setSource\":\n        setSourceNode(null);\n        setTargetNode(null);\n        resetAllEdgeAnimation();\n        return;\n      case \"running\":\n        if (index.current === 0) resetAllEdgeAnimation();\n        if (\n          target !== null &&\n          !checkConnectedComponents(nodes, edges, source!, target!)\n        ) {\n          algoDispatch({\n            type: \"error\",\n            newStatus: \"Error: Nodes must be connected.\",\n          });\n          return;\n        }\n\n        if (algoState.category === \"path\") {\n          const [traversed, shortestPath] = runPathAlgorithm(\n            algoState.name!,\n            nodes,\n            edges\n          );\n          if (!traversed.length || !shortestPath.length) {\n            algoDispatch({ type: \"error\", newStatus: \"Error: No path found\" });\n            return;\n          }\n          algoOutput.current = traversed;\n          algoPath.current = shortestPath;\n          visualizePath(algoOutput.current!, algoPath.current);\n        } else if (algoState.category === \"tree\") {\n          const [traversed, shortestPath] = runTreeAlgorithm(\n            algoState.name!,\n            nodes,\n            edges\n          );\n          if (!traversed.length || !shortestPath.length) {\n            algoDispatch({ type: \"error\", newStatus: \"Error: No path found\" });\n            return;\n          }\n          algoOutput.current = traversed;\n          algoPath.current = shortestPath;\n          visualizeMST(algoOutput.current!, algoPath.current);\n        } else if (algoState.category === \"flow\") {\n          const [traversed, maxFlow] = runFlowAlgorithm(\n            algoState.name!,\n            nodes,\n            edges\n          );\n          if (!traversed.length) {\n            algoDispatch({ type: \"error\", newStatus: \"Error: No path found\" });\n            return;\n          }\n          algoOutput.current = traversed;\n          maxFlowOutput.current = maxFlow;\n          console.log(maxFlow);\n          visualizeMaxFlow(algoOutput.current!, maxFlow);\n        }\n        return;\n\n      case \"paused\":\n        clearTimeout(timer.current!);\n        return;\n      case \"ready\":\n        clearTimeout(timer.current!);\n        return;\n      case \"stepF\":\n        stepAlgorithmForward();\n        return;\n      case \"stepB\":\n        stepAlgorithmBackward();\n        return;\n      case null:\n        clearTimeout(timer.current!);\n        resetAllEdgeAnimation();\n        return;\n    }\n  }, [algoState.status]);\n\n  useEffect(() => {\n    if (clearGraphs) {\n      nodes.forEach((node) => deleteNode(node.id));\n      offClear();\n    }\n  }, [clearGraphs]);\n\n  const setMouseDownNode = (nodeID: string | null): void => {\n    if (nodeID === null) {\n      mouseDownNode.current = null;\n      setGhostEdge((prev) => null);\n      return;\n    }\n\n    const node = nodes.find((n) => nodeID === n.id);\n    if (node !== undefined) mouseDownNode.current = node;\n  };\n\n  const addNode = (coor: { screenX: number; screenY: number }): void => {\n    let [x, y] = screenToWorld({\n      offsetX: transformState.offsetX,\n      offsetY: transformState.offsetY,\n      iScreenX: coor.screenX,\n      iScreenY: coor.screenY,\n      scale: transformState.scale,\n    });\n\n    const id: string = uuidv4();\n    const node = {\n      id: id,\n      x: x,\n      y: y,\n      outEdgeIDs: [],\n      inEdgeIDs: [],\n      dist: Infinity,\n      prev: null,\n    };\n    setNodes((prevNodes) => [...prevNodes, node]);\n  };\n\n  const deleteNode = (nodeID: string) => {\n    if (algoState.ready) return;\n\n    const node = nodes.find((n) => n.id === nodeID);\n    if (node === undefined) return;\n\n    setNodes((prevNodes) => {\n      return prevNodes.filter((prevNode) => {\n        return prevNode.id !== nodeID;\n      });\n    });\n    deleteIncidentEdges(node);\n  };\n\n  const updateIncidentEdges = (head: Node, tail: Node, edge: Edge) => {\n    setNodes((prevNodes) => {\n      return prevNodes.map((node) => {\n        if (node === head) {\n          node.outEdgeIDs!.push(edge.id);\n        } else if (node === tail) {\n          node.inEdgeIDs!.push(edge.id);\n        }\n        return node;\n      });\n    });\n  };\n\n  const updateNodeCoordinate = (node: Node, x: number, y: number) => {\n    setNodes((prevNodes) => {\n      return prevNodes.map((node) => {\n        if (node === mouseDownNode.current) {\n          node.x = Math.round(x);\n          node.y = Math.round(y);\n        }\n        return node;\n      });\n    });\n  };\n\n  const updateGhostEdge = (event: React.MouseEvent<HTMLDivElement>): void => {\n    if (mouseDownNode.current === null) return;\n\n    let [x, y] = screenToWorld({\n      offsetX: transformState.offsetX,\n      offsetY: transformState.offsetY,\n      iScreenX: event.clientX,\n      iScreenY: event.clientY - MENUBAR_OFFSET,\n      scale: transformState.scale,\n    });\n    const tail = {\n      x: x,\n      y: y,\n    };\n    const newGhostEdge = {\n      headNode: mouseDownNode.current,\n      tailPosition: tail,\n    };\n    setGhostEdge((prev) => newGhostEdge);\n  };\n\n  const addEdge = (headNode: Node, tailNode: Node) => {\n    if (edges.find((e) => e.headNode === headNode && e.tailNode === tailNode))\n      return;\n    const edgeLength = Math.round(\n      getDistance(headNode.x, headNode.y, tailNode.x, tailNode.y)\n    );\n\n    const newEdge: Edge = {\n      id: uuidv4(),\n      headNode: headNode,\n      tailNode: tailNode,\n      weight: edgeLength,\n      animation: null,\n      optionalValue: 0,\n    };\n    updateIncidentEdges(headNode, tailNode, newEdge);\n    setEdges((prevEdges) => [...prevEdges, newEdge]);\n  };\n\n  const deleteEdge = (edgeID: string): void => {\n    if (algoState.ready) return;\n    if (dKeyPressed.current) {\n      setEdges((prevEdges) => {\n        return prevEdges.filter((e) => e.id !== edgeID);\n      });\n    }\n  };\n\n  const deleteIncidentEdges = (node: Node): void => {\n    const incidentEdgeIDs = [...node.inEdgeIDs!, ...node.outEdgeIDs!];\n    setEdges((prevEdges) => {\n      return prevEdges.filter(\n        (prevEdge) => !incidentEdgeIDs.includes(prevEdge.id)\n      );\n    });\n  };\n\n  const updateEdgeWeight = (edgeID: string, newWeight: number) => {\n    setEdges((prevEdges) => {\n      return prevEdges.map((edge) => {\n        if (edgeID === edge.id) {\n          edge.weight = newWeight;\n        }\n        return edge;\n      });\n    });\n  };\n\n  /****** Event Handlers ******/\n\n  const handleMouseUpOnNode = (nodeID: string) => {\n    if (mouseDownNode.current === null) return;\n    if (isMovingNode.current === true) {\n      isMovingNode.current = false;\n      mouseDownNode.current = null;\n      return;\n    }\n\n    if (mouseDownNode.current.id === nodeID) {\n      // Handle delete node\n      if (dKeyPressed.current) {\n        deleteNode(nodeID);\n        setGhostEdge((prev) => null);\n        mouseDownNode.current = null;\n        return;\n      }\n\n      // Handle setting source and target\n      if (algoState.status === \"setSource\") {\n        setSourceNode(mouseDownNode.current);\n        const currStatus =\n          algoState.category === \"tree\" ? \"ready\" : \"setTarget\";\n        const isReady = algoState.category === \"tree\" ? true : false;\n        algoDispatch({\n          type: \"setStatus\",\n          newStatus: currStatus,\n          ready: isReady,\n        });\n        mouseDownNode.current = null;\n        return;\n      } else if (algoState.status === \"setTarget\") {\n        if (mouseDownNode.current === source) {\n          // Reset Source\n          setSourceNode(mouseDownNode.current);\n          algoDispatch({\n            type: \"setStatus\",\n            newStatus: \"setSource\",\n            ready: false,\n          });\n          mouseDownNode.current = null;\n          return;\n        }\n        setTargetNode(mouseDownNode.current);\n        algoDispatch({ type: \"setStatus\", newStatus: \"ready\", ready: true });\n        mouseDownNode.current = null;\n        return;\n      }\n      mouseDownNode.current = null;\n      return;\n    } else {\n      // Handle add edge\n      const head = mouseDownNode.current;\n      const tail = nodes.find((n) => n.id === nodeID);\n      if (tail !== undefined) addEdge(head!, tail);\n      mouseDownNode.current = null;\n      setGhostEdge((prev) => null);\n    }\n  };\n\n  const handleMouseUp = (event: React.MouseEvent<HTMLDivElement>) => {\n    if (mouseDownNode.current !== null) {\n      setMouseDownNode(null);\n      mouseIsHeld.current = false;\n      return;\n    }\n    if (mouseIsHeld.current && mouseMoved.current) {\n      mouseIsHeld.current = false;\n      mouseMoved.current = false;\n      return;\n    }\n    if (mouseDownNode.current === null) {\n      addNode({\n        screenX: event.clientX,\n        screenY: event.clientY - MENUBAR_OFFSET,\n      });\n      mouseIsHeld.current = false;\n    }\n  };\n\n  const handleMouseMove = (event: React.MouseEvent<HTMLDivElement>) => {\n    event.preventDefault();\n    if (\n      event.shiftKey &&\n      mouseDownNode.current !== null &&\n      ghostEdge === null\n    ) {\n      isMovingNode.current = true;\n      let [currX, currY] = screenToWorld({\n        offsetX: transformState.offsetX,\n        offsetY: transformState.offsetY,\n        iScreenX: event.clientX,\n        iScreenY: event.clientY - MENUBAR_OFFSET,\n        scale: transformState.scale,\n      });\n      updateNodeCoordinate(mouseDownNode.current, currX, currY);\n      return;\n    }\n\n    if (mouseIsHeld.current) {\n      mouseMoved.current = true;\n      pan({ movementX: event.movementX, movementY: event.movementY });\n      return;\n    }\n\n    if (mouseDownNode.current !== null) {\n      updateGhostEdge(event);\n      return;\n    }\n  };\n\n  const handleWheel = (event: React.WheelEvent<HTMLDivElement>) => {\n    let delta = event.deltaY > 0 ? -1 : 1;\n    zoom({\n      pageX: event.pageX,\n      pageY: event.pageY - MENUBAR_OFFSET,\n      delta: delta,\n    });\n  };\n\n  const handleKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {\n    if (event.key === \"d\") {\n      dKeyPressed.current = true;\n    }\n  };\n\n  const handleKeyUp = (event: React.KeyboardEvent<HTMLDivElement>) => {\n    if (event.key === \"d\") {\n      dKeyPressed.current = false;\n    }\n  };\n\n  const handleMouseDown = (\n    event: React.MouseEvent<HTMLDivElement, MouseEvent>\n  ) => {\n    mouseIsHeld.current = true;\n  };\n\n  return (\n    <StyledDiv\n      onMouseDown={handleMouseDown}\n      onMouseUp={handleMouseUp}\n      onMouseMove={handleMouseMove}\n      onWheel={handleWheel}\n      onKeyDown={handleKeyDown}\n      onKeyUp={handleKeyUp}\n      tabIndex={0}\n      style={{\n        transformOrigin: `top left`,\n        transform: `scale(${transformState.scale}, ${transformState.scale}) translate(${transformState.offsetX}px, ${transformState.offsetY}px)`,\n      }}\n    >\n      {nodes.map((node) => {\n        return (\n          <GraphNode\n            key={node.id}\n            id={node.id}\n            className={\"node\"}\n            x={node.x}\n            y={node.y}\n            handleMouseDown={setMouseDownNode}\n            handleMouseUp={handleMouseUpOnNode}\n            isSource={source === node}\n            isTarget={target === node}\n          />\n        );\n      })}\n      {edges.map((edge) => {\n        return (\n          <GraphEdge\n            key={edge.id}\n            id={edge.id}\n            className={\"edge\"}\n            headNode={edge.headNode}\n            tailNode={edge.tailNode}\n            weight={edge.weight}\n            handleClick={deleteEdge}\n            showLabel={showLabel}\n            animation={edge.animation}\n            optionalValue={edge.optionalValue}\n            interval={interval.current}\n            updateEdgeWeight={updateEdgeWeight}\n          />\n        );\n      })}\n      {ghostEdge !== null && (\n        <GhostEdge\n          className={\"ghostedge\"}\n          headNode={ghostEdge.headNode}\n          tailPosition={ghostEdge.tailPosition}\n        />\n      )}\n    </StyledDiv>\n  );\n};\n\nexport default Canvas;\n","import Canvas from \"./Canvas\";\nimport * as CanvasModules from \"./Canvas\";\n\nexport type Node = CanvasModules.Node;\nexport type Edge = CanvasModules.Edge;\nexport default Canvas;\n","import React from \"react\";\nimport styled from \"styled-components\";\n\nimport { useAlgoState, useAlgoDispatch } from \"Contexts/AlgorithmContext\";\n\ninterface TitleProps {}\n\nconst StyledTitle = styled.h1`\n  color: #ffffff;\n  font-family: \"Montserrat\", sans-serif;\n  margin-top: 1em;\n  margin-bottom: 1em;\n  margin-right: 50px;\n  font-size: 1.5em;\n  cursor: pointer;\n`;\n\nconst Title: React.FC<TitleProps> = (props) => {\n  const algoState = useAlgoState();\n  const algoDispatch = useAlgoDispatch();\n\n  const handleClick = (\n    event: React.MouseEvent<HTMLHeadingElement, MouseEvent>\n  ) => {\n    if (\n      algoState.status === \"setSource\" ||\n      algoState.status === \"setTarget\" ||\n      algoState.status === \"ready\" ||\n      algoState.status === \"completed\" ||\n      (algoState.status !== null && algoState.status.includes(\"Error\"))\n    ) {\n      algoDispatch({ type: \"reset\" });\n    }\n  };\n\n  return <StyledTitle onClick={handleClick}>{props.children}</StyledTitle>;\n};\n\nexport default Title;\n","import Title from \"./Title\";\n\nexport default Title;\n","import React, { useRef } from \"react\";\nimport styled from \"styled-components\";\n\nconst StyledTab = styled.div`\n  font-family: \"Montserrat\", sans-serif;\n  font-size: 16px;\n  font-weight: 500;\n  color: white;\n  padding: 0 10px;\n  background: none;\n  transition: opacity 0.2s;\n  -webkit-font-smoothing: antialiased;\n  cursor: pointer;\n\n  &:hover {\n    opacity: 0.5;\n  }\n`;\n\ninterface NavTabProps {\n  name: string;\n  onMouseOver: (id: string, tabRef: HTMLDivElement | null) => void;\n}\n\nconst NavTab: React.FC<NavTabProps> = (props) => {\n  const navTabRef = useRef<HTMLDivElement | null>(null);\n\n  return (\n    <StyledTab\n      ref={navTabRef}\n      onMouseOver={() => props.onMouseOver(props.name, navTabRef.current)}\n    >\n      {props.children}\n    </StyledTab>\n  );\n};\n\nexport default NavTab;\n","import NavTab from \"./NavTab\";\n\nexport default NavTab;\n","import React, { useState, useEffect, useCallback } from \"react\";\nimport styled from \"styled-components\";\n\nimport { useAlgoDispatch } from \"Contexts/AlgorithmContext\";\n\nexport interface PopOverState {\n  name: string;\n  content: string[];\n  tabRef: HTMLDivElement | null;\n  show: boolean;\n}\n\ninterface PopOverProps {\n  state: PopOverState;\n}\n\nconst StyledContainer = styled(\"div\")<{ show: boolean }>`\n  position: absolute;\n  opacity: ${(props) => (props.show ? 1 : 0)};\n  transform-origin: center -20px;\n  transform: ${(props) => (props.show ? `rotateX(0deg)` : `rotateX(-15deg)`)};\n  transition: transform 0.3s, opacity 0.3s;\n  pointer-events: ${(props) => (props.show ? \"auto\" : \"none\")};\n`;\n\nconst Content = styled(\"ul\")<{ xCoor: number; yCoor: number }>`\n  position: absolute;\n  /* left: ${(props) => props.xCoor}px; */\n  top: ${(props) => props.yCoor}px;\n  z-index: 1;\n\n  padding-inline-start: 0px;\n  margin-block-start: 0px;\n  margin-block-end: 0px;\n  padding: 32px 0px;\n\n  transform: translateX(${(props) => props.xCoor}px);\n  transition: transform 0.3s, opacity 0.3s;\n`;\n\nconst ContentItem = styled(\"li\")<{ show: boolean }>`\n  list-style-type: none;\n  font-family: \"Open sans\", sans-serif;\n  font-size: 20px;\n  letter-spacing: 0.025em;\n  text-transform: uppercase;\n  font-weight: 600;\n  padding: 8px 16px;\n  color: #00b8a9;\n  cursor: ${(props) => (props.show ? \"pointer\" : \"default\")};\n\n  &:hover {\n    background-color: #f1f1f1;\n  }\n`;\n\ninterface IBackGround {\n  xCoor: number;\n  yCoor: number;\n  contentHeight: number;\n  contentWidth: number;\n}\n\nconst Background = styled(\"div\")<IBackGround>`\n  position: absolute;\n  /* left: ${(props) => props.xCoor - 25}px; */\n  top: ${(props) => props.yCoor}px;\n  width: ${(props) => props.contentWidth + 100}px;\n  height: ${(props) => props.contentHeight}px;\n\n  background: white;\n  border-radius: 6px;\n  box-shadow: 0 50px 100px -20px rgba(50, 50, 93, 0.25),\n    0 30px 60px -30px rgba(0, 0, 0, 0.3);\n  transform-origin: 0 0;\n  transform: translateX(${(props) => props.xCoor - 25}px);\n  transition: transform 0.3s, opacity 0.3s;\n`;\n\nconst Arrow = styled(\"div\")<{ xCoor: number; yCoor: number }>`\n  width: 12px;\n  height: 12px;\n  background: white;\n  box-shadow: -3px -3px 5px rgba(80, 90, 120, 0.05);\n  border-radius: 4px 0 0 0;\n  transform: rotate(45deg) translateX(${(props) => props.xCoor - 25}px);\n  transition: transform 0.3s, opacity 0.3s;\n  will-change: transform;\n`;\n\nconst PopOver: React.FC<PopOverProps> = ({ state }) => {\n  const [contentRef, setContentRef] = useState<HTMLUListElement | null>(null);\n  const [contentSize, setContentSize] = useState<number[]>([0, 0]);\n\n  const dispatch = useAlgoDispatch();\n\n  const onRefChange = useCallback(\n    (node: HTMLUListElement | null): void => {\n      setContentRef((prev) => node);\n    },\n    [setContentRef]\n  );\n\n  useEffect(() => {\n    if (contentRef !== null) {\n      setContentSize((prev) => [\n        contentRef.offsetHeight,\n        contentRef.offsetWidth,\n      ]);\n    }\n  }, [state.tabRef, setContentSize]);\n\n  const x = state.tabRef?.getBoundingClientRect().left;\n  const y = state.tabRef?.getBoundingClientRect().top;\n\n  const handleClick = (item: string) => {\n    if (state.name === \"path\") {\n      dispatch({\n        type: \"set\",\n        newName: item,\n        category: state.name,\n        newStatus: \"setSource\",\n      });\n    }\n    if (state.name === \"tree\") {\n      dispatch({\n        type: \"set\",\n        newName: item,\n        category: state.name,\n        newStatus: \"setSource\",\n      });\n    }\n    if (state.name === \"flow\") {\n      dispatch({\n        type: \"set\",\n        newName: item,\n        category: state.name,\n        newStatus: \"setSource\",\n      });\n    }\n  };\n\n  return (\n    <StyledContainer show={state.show}>\n      <Content ref={onRefChange} xCoor={x!} yCoor={y!}>\n        {state.content.map((item, index) => (\n          <ContentItem\n            key={index}\n            onClick={() => {\n              handleClick(item);\n            }}\n            show={state.show}\n          >\n            {item}\n          </ContentItem>\n        ))}\n      </Content>\n\n      {contentRef !== null && (\n        <Background\n          xCoor={x!}\n          yCoor={y!}\n          contentHeight={contentSize[0]}\n          contentWidth={contentSize[1]}\n        />\n      )}\n    </StyledContainer>\n  );\n};\n\nexport default PopOver;\n","import PopOver from \"./PopOver\";\nimport * as PopOverModules from \"./PopOver\";\n\nexport type PopOverState = PopOverModules.PopOverState;\nexport default PopOver;\n","import React, { useState, useRef, useCallback } from \"react\";\nimport styled from \"styled-components\";\nimport Title from \"./Title\";\nimport NavTab from \"./NavTab\";\nimport PopOver, { PopOverState } from \"./PopOver\";\nimport { useAlgoState } from \"Contexts/AlgorithmContext\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faQuestionCircle } from \"@fortawesome/free-regular-svg-icons\";\n\ninterface NavbarProps {\n  onClear: () => void;\n  onQuestionClick: () => void;\n}\n\nconst StyledNav = styled(\"nav\")<{ show: boolean }>`\n  flex: 1;\n  top: -200px;\n  background: #e94560;\n  padding: 10px 25px;\n  display: flex;\n  align-items: center;\n  position: relative;\n  transform: translateY(${(props) => (props.show ? 200 : -200)}px);\n  transition: transform 0.5s;\n  z-index: 2;\n`;\n\nconst ClearButton = styled(\"button\")`\n  background-color: white;\n  border: none;\n  border-radius: 1rem;\n  color: #e94560;\n  padding: 16px 32px;\n  text-align: center;\n  text-decoration: none;\n  display: inline-block;\n  font-size: 16px;\n  font-family: \"Open sans\", sans-serif;\n  font-weight: 600;\n  transition-duration: 0.4s;\n  cursor: pointer;\n  position: absolute;\n  right: 50px;\n\n  &:hover {\n    background-color: #f1fa3c;\n    color: #16213e;\n  }\n`;\n\nconst QuestionCircle = styled(FontAwesomeIcon)`\n  font-size: 20px;\n  cursor: pointer;\n  transition: opacity 0.5s;\n  position: absolute;\n  right: 250px;\n\n  &:hover {\n    opacity: 0.5;\n  }\n`;\n\nconst popOverContent: { [string: string]: string[] } = {\n  path: [\"dfs\", \"bfs\", \"dijkstra\", \"a*\"],\n  tree: [\"prim\", \"kruskal\"],\n  flow: [\"fulkerson\"],\n};\n\nconst initialPopOver = {\n  name: \"\",\n  content: [],\n  tabRef: null,\n  show: false,\n};\n\nconst Navbar: React.FC<NavbarProps> = (props) => {\n  const [popOver, setPopOver] = useState<PopOverState>(initialPopOver);\n  const algorithmState = useAlgoState();\n\n  const showPopOver = useCallback(\n    (name: string, tabRef: HTMLDivElement | null): void => {\n      setPopOver((prev) => {\n        return {\n          name: name,\n          content: popOverContent[name],\n          tabRef: tabRef,\n          show: true,\n        };\n      });\n    },\n    [setPopOver]\n  );\n\n  const hidePopOver = useCallback(() => {\n    setPopOver((prev) => {\n      return {\n        ...prev,\n        show: false,\n      };\n    });\n  }, [setPopOver]);\n\n  return (\n    <StyledNav onMouseLeave={hidePopOver} show={algorithmState.name === null}>\n      <Title>Graphii</Title>\n      <NavTab name={\"path\"} onMouseOver={showPopOver}>\n        Path Finding\n      </NavTab>\n      <NavTab name={\"tree\"} onMouseOver={showPopOver}>\n        Spanning Trees\n      </NavTab>\n      <NavTab name={\"flow\"} onMouseOver={showPopOver}>\n        Max-Flow\n      </NavTab>\n      <PopOver state={popOver} />\n      <QuestionCircle\n        icon={faQuestionCircle}\n        color=\"white\"\n        onClick={() => props.onQuestionClick()}\n      />\n      <ClearButton onClick={() => props.onClear()}>Clear Canvas</ClearButton>\n    </StyledNav>\n  );\n};\n\nexport default Navbar;\n","import Navbar from \"./Navbar\";\n\nexport default Navbar;\n","import React, { useState, useEffect } from \"react\";\nimport styled, { keyframes } from \"styled-components\";\nimport Title from \"Components/App/Container/Navbar/Title\";\nimport { useAlgoState, useAlgoDispatch } from \"Contexts/AlgorithmContext\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  faStepForward,\n  faStepBackward,\n  faPlay,\n  faPause,\n  faRedo,\n} from \"@fortawesome/free-solid-svg-icons\";\n\nconst Container = styled(\"div\")<{\n  show: boolean;\n  color: string;\n  category: string | null;\n}>`\n  top: -200px;\n  transform: translateY(${(props) => (props.show ? 200 : -200)}px);\n  transition: transform 0.5s;\n  display: flex;\n  background: ${(props) => props.color};\n  padding: 10px 25px;\n  align-items: center;\n  width: 100%;\n  position: absolute;\n  z-index: 2;\n`;\n\nconst TitleContainer = styled(\"div\")`\n  flex: 1;\n`;\n\nconst ConfigContainer = styled(\"div\")`\n  display: flex;\n  flex: 2;\n  justify-content: center;\n`;\n\nconst StyledIcon = styled(FontAwesomeIcon)<{ clickable: boolean }>`\n  font-size: 24px;\n  padding: 0px 25px;\n  cursor: ${(props) => (props.clickable ? \"pointer\" : \"cursor\")};\n  opacity: ${(props) => (props.clickable ? 1 : 0.5)};\n  transition: opacity 0.3s;\n\n  &:hover {\n    opacity: 0.5;\n  }\n`;\n\nconst Slider = styled(\"input\")`\n  -webkit-appearance: none;\n  width: 150px;\n  height: 15px;\n  margin-left: 50px;\n  border-radius: 100px;\n  background: white;\n  outline: none;\n  -webkit-transition: 0.2s;\n  transition: opacity 0.2s;\n\n  ::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    appearance: none;\n    width: 25px;\n    height: 25px;\n    border-radius: 50%;\n    background: #21e6c1;\n    cursor: pointer;\n  }\n\n  ::-moz-range-thumb {\n    width: 25px;\n    height: 25px;\n    border-radius: 50%;\n    background: #21e6c1;\n    cursor: pointer;\n  }\n`;\n\nconst fadeIn = keyframes`\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n`;\n\nconst MessageContainer = styled(\"div\")`\n  flex: 2;\n  display: flex;\n  justify-content: center;\n  color: white;\n  font-size: 20px;\n  font-family: \"Open sans\", sans-serif;\n  font-weight: 900;\n  animation: 2s ${fadeIn};\n`;\n\nconst RightContainer = styled(\"div\")`\n  flex: 1;\n`;\n\nconst CancelButton = styled(\"button\")<{ color: string }>`\n  background-color: white;\n  border: none;\n  border-radius: 1rem;\n  color: ${(props) => props.color};\n  padding: 16px 32px;\n  text-align: center;\n  text-decoration: none;\n  display: inline-block;\n  font-size: 16px;\n  font-family: \"Open sans\", sans-serif;\n  font-weight: 600;\n  margin: 4px 2px;\n  transition-duration: 0.4s;\n  cursor: pointer;\n\n  &:hover {\n    background-color: #e94560;\n    color: white;\n  }\n`;\n\nconst AlgorithmBar: React.FC<{ changeSpeed: (value: number) => void }> = ({\n  changeSpeed,\n}) => {\n  const algoState = useAlgoState();\n  const algoDispatch = useAlgoDispatch();\n\n  const [message, setMessage] = useState<string>(\"\");\n  const [color, setColor] = useState<string>(\"\");\n\n  useEffect(() => {\n    switch (algoState.status) {\n      case \"setSource\": {\n        let msg =\n          algoState.category === \"path\"\n            ? \"Select start node.\"\n            : algoState.category === \"tree\"\n            ? \"Select root node.\"\n            : \"Select source node.\";\n        setMessage((prev) => msg);\n        return;\n      }\n      case \"setTarget\": {\n        let msg =\n          algoState.category === \"path\"\n            ? \"Select destination node.\"\n            : \"Select sink node.\";\n        setMessage((prev) => msg);\n        return;\n      }\n      case \"ready\":\n        setMessage((prev) => \"Visualize!\");\n        return;\n      case \"running\":\n        setMessage(\"Visualize!\");\n        return;\n      case \"completed\":\n        setMessage(`Completed; ${algoState.value}`);\n        return;\n      default:\n        setMessage(algoState.status!);\n        return;\n    }\n  }, [algoState.status]);\n\n  useEffect(() => {\n    switch (algoState.category) {\n      case \"path\":\n        setColor((prev) => \"#00b8a9\");\n        return;\n      case \"tree\":\n        setColor((prev) => \"#b8de6f\");\n        return;\n      case \"flow\":\n        setColor((prev) => \"#4c6ef5\");\n        return;\n    }\n  }, [algoState.category]);\n\n  return (\n    <Container\n      show={algoState.name !== null}\n      color={color}\n      category={algoState.category}\n    >\n      <TitleContainer>\n        <Title>{algoState.name}</Title>\n      </TitleContainer>\n\n      <ConfigContainer>\n        <StyledIcon\n          icon={faStepBackward}\n          color=\"white\"\n          clickable={\n            algoState.ready &&\n            algoState.status !== \"ready\" &&\n            algoState.status !== \"completed\" &&\n            algoState.status !== \"running\"\n          }\n          onClick={() => {\n            if (\n              !algoState.ready ||\n              algoState.status === \"completed\" ||\n              algoState.status === \"ready\" ||\n              algoState.status === \"running\"\n            )\n              return;\n            algoState.status === \"paused\" && algoDispatch({ type: \"stepB\" });\n          }}\n        />\n        <StyledIcon\n          icon={\n            algoState.status === \"completed\"\n              ? faRedo\n              : algoState.status === \"running\" ||\n                algoState.status === \"continuing\"\n              ? faPause\n              : faPlay\n          }\n          color=\"white\"\n          onClick={() => {\n            if (!algoState.ready) return;\n            algoState.status === \"ready\" || algoState.status === \"completed\"\n              ? algoDispatch({ type: \"start\" })\n              : algoState.status === \"running\" ||\n                algoState.status === \"continuing\"\n              ? algoDispatch({ type: \"pause\" })\n              : algoState.status === \"paused\" &&\n                algoDispatch({ type: \"continue\" });\n          }}\n          clickable={algoState.ready}\n        />\n        <StyledIcon\n          icon={faStepForward}\n          color=\"white\"\n          clickable={\n            algoState.ready &&\n            algoState.status !== \"completed\" &&\n            algoState.status !== \"running\"\n          }\n          onClick={() => {\n            if (\n              !algoState.ready ||\n              algoState.status === \"completed\" ||\n              algoState.status === \"running\"\n            )\n              return;\n            algoState.status === \"paused\" && algoDispatch({ type: \"stepF\" });\n          }}\n        />\n        <Slider\n          type=\"range\"\n          min={0.5}\n          max={3}\n          defaultValue={1}\n          step={0.01}\n          onChange={(e) => changeSpeed(parseFloat(e.target.value))}\n        />\n      </ConfigContainer>\n\n      <MessageContainer>{message}</MessageContainer>\n\n      <RightContainer>\n        <CancelButton\n          color={color}\n          onClick={() => algoDispatch({ type: \"cancel\" })}\n        >\n          Cancel\n        </CancelButton>\n      </RightContainer>\n    </Container>\n  );\n};\n\nexport default AlgorithmBar;\n","import AlgorithmBar from \"./AlgorithmBar\";\n\nexport default AlgorithmBar;\n","import React, { useState } from \"react\";\nimport styled, { keyframes } from \"styled-components\";\n\ninterface ModalProps {\n  isOpen: boolean;\n  toggle: () => void;\n}\n\nconst slideIn = keyframes`\n  from {top:-700px; opacity:0} \n  to {top:125px; opacity:1}\n`;\n\nconst Overlay = styled.div<{ show: boolean }>`\n  display: ${(props) => (props.show ? \"block\" : \"none\")};\n  position: fixed;\n  z-index: 2;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(0, 0, 0, 0.3);\n`;\n\nconst StyledModal = styled.div<{ show: boolean }>`\n  display: ${(props) => (props.show ? \"block\" : \"none\")};\n  position: fixed;\n  left: 12.5%;\n  width: 75%;\n  height: 530px;\n  overflow: auto;\n  background-color: #f6f9fc;\n  color: #16213e;\n  z-index: 2;\n  border-radius: 4px;\n  text-align: center;\n  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\n  animation: ${slideIn} 0.3s ease-out forwards;\n`;\n\nconst ModalTitle = styled.h2`\n  font-family: \"Montserrat\", sans-serif;\n  font-size: 3em;\n  line-height: 3em;\n  height: 3em;\n  margin: 0px auto;\n  text-align: center;\n`;\n\nconst ModalSubTitle = styled.h4`\n  font-family: \"Open sans\", sans-serif;\n  font-size: 1em;\n  line-height: 1em;\n  height: 1em;\n  margin: 0px auto;\n  text-align: center;\n`;\n\nconst InstructionList = styled.ul`\n  display: inline-block;\n  width: 75%;\n  text-align: left;\n`;\n\nconst InstructionItem = styled.li`\n  list-style-type: none;\n  font-family: \"Open sans\", sans-serif;\n  font-size: 1rem;\n  padding: 10px 0;\n`;\n\nconst Bold = styled.i`\n  font-weight: bold;\n`;\n\nconst Modal: React.FC<ModalProps> = ({ isOpen, toggle }) => {\n  return (\n    <>\n      <Overlay onClick={() => toggle()} show={isOpen} />\n      <StyledModal show={isOpen}>\n        <ModalTitle>Welcome To Graphii</ModalTitle>\n        <ModalSubTitle>\n          Before you get started, here is a list of instructions on how to use\n          this application.\n        </ModalSubTitle>\n        <ModalSubTitle>Please use Chrome or Firefox for optimal user experience.</ModalSubTitle>\n        <InstructionList>\n          <InstructionItem>\n            <Bold>Add/Delete a Node</Bold>: Left click on the canvas to create a\n            node. Press 'd' as you click on a node to delete.\n          </InstructionItem>\n          <InstructionItem>\n            <Bold>Move a Node</Bold>: Hold the shift key and simply drag the\n            node.\n          </InstructionItem>\n          <InstructionItem>\n            <Bold>Add/Delete an Edge</Bold>: Press left mouse down onto a node\n            and drag onto another node.\n          </InstructionItem>\n          <InstructionItem>\n            <Bold>Edit Edge Weight</Bold>: Press 'w' to display weights. By\n            default they are set as edge lengths. Click to edit.\n          </InstructionItem>\n          <InstructionItem>\n            <Bold>Zoom the Canvas</Bold>: Scroll up and scroll down.\n          </InstructionItem>\n          <InstructionItem>\n            <Bold>Pan the Canvas</Bold>: Drag the canvas.\n          </InstructionItem>\n          <InstructionItem>\n            <Bold>Visualize an Algorithm</Bold>: Select an algorithm from the\n            popover and follow instructions. You are able to play, pause, step,\n            and change speed of an algorithm being visualized.\n          </InstructionItem>\n          <InstructionItem>\n            <Bold>Reset Source and Targets</Bold>: Click on the algorithm title.\n          </InstructionItem>\n        </InstructionList>\n      </StyledModal>\n    </>\n  );\n};\n\nexport default Modal;\n","import Modal from \"./Modal\";\n\nexport default Modal;\n","import React, { useState } from \"react\";\nimport styled from \"styled-components\";\nimport { useKeyDispatch } from \"Contexts/KeyContext\";\n\nimport Canvas from \"./Canvas\";\nimport Navbar from \"./Navbar\";\nimport AlgorithmBar from \"./AlgorithmBar\";\nimport Modal from \"./Modal\";\n\ninterface ContainerProps {\n  children?: React.ReactNode;\n}\n\nconst StyledDiv = styled.div`\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  background-color: #16213e;\n`;\n\nconst Container: React.FC<ContainerProps> = () => {\n  const [clear, setClear] = useState<boolean>(false);\n  const [speed, setSpeed] = useState<number>(1);\n  const [isOpen, setIsOpen] = useState<boolean>(true);\n\n  const keyDispatch = useKeyDispatch();\n\n  const handleKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {\n    keyDispatch({ type: \"press\", key: event.key });\n  };\n\n  const handleKeyUp = (event: React.KeyboardEvent<HTMLDivElement>) => {\n    keyDispatch({ type: \"unpress\", key: event.key });\n  };\n\n  const setClearTrue = () => {\n    setClear((prev) => true);\n  };\n\n  const setClearFalse = () => {\n    setClear((prev) => false);\n  };\n\n  const handleChangeSpeed = (newValue: number) => {\n    setSpeed((prev) => newValue);\n  };\n\n  const handleToggle = () => {\n    setIsOpen((prev) => !prev);\n  };\n\n  return (\n    <StyledDiv onKeyDown={handleKeyDown} onKeyUp={handleKeyUp}>\n      <Navbar onClear={setClearTrue} onQuestionClick={handleToggle} />\n      <AlgorithmBar changeSpeed={handleChangeSpeed} />\n      <Canvas clearGraphs={clear} offClear={setClearFalse} speed={speed} />\n      <Modal isOpen={isOpen} toggle={handleToggle} />\n    </StyledDiv>\n  );\n};\n\nexport default Container;\n","import Container from \"./Container\";\n\nexport default Container;\n","import App from \"./App\";\n\nexport default App;\n","import React from \"react\";\nimport { AlgoProvider } from \"Contexts/AlgorithmContext\";\nimport { KeyProvider } from \"Contexts/KeyContext\";\n\nimport Container from \"./Container\";\n\nconst App: React.FC = () => {\n  return (\n    <KeyProvider>\n      <AlgoProvider>\n        <Container />\n      </AlgoProvider>\n    </KeyProvider>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"Components/App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}